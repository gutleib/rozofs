#!/usr/bin/python
# -*- coding: utf-8 -*-
# Copyright (c) 2010 Fizians SAS. <http://www.fizians.com>
# This file is part of Rozofs.
#
# Rozofs is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 2.
#
# Rozofs is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see
# <http://www.gnu.org/licenses/>.
import sys
import os.path
import subprocess
import time
import re
import shlex
import shutil
import json

import sys
import re

red = '\033[91m'
green = '\033[92m'
yellow = '\033[93m'
blue = '\033[94m'
purple = '\033[95m'
cyan = '\033[96m'
white = '\033[97m'
endeffect = '\033[0m'
bold = '\033[1m'
underline = '\033[4m'
blink = '\033[5m'
reverse = '\033[7m'


strip_ANSI_pat = re.compile(r"""
    \x1b     # literal ESC
    \[       # literal [
    [;\d]*   # zero or more digits or semicolons
    [A-Za-z] # a letter
    """, re.VERBOSE).sub

def strip_ANSI(s):
    return strip_ANSI_pat("", s)

#_______________________________________________
class constants:

  def joined_column(self): return "#Zis_IZ_a_JoInED_ColUMn"
  
#_______________________________________________
class column_desc:

  def __init__(self,shift):  
    self.column_nb    = 0
    self.column_sizes = []
    self.shift        = shift
     
  def update_column(self, num, size):
  
    # Column number extension
    if int(num) > self.column_nb:
      for i in range(self.column_nb,num):
        self.column_sizes.append('0')
      self.column_nb = num 	
	
    # Column size extension
    if int(self.column_sizes[int(num)-1]) < int(size):
      self.column_sizes[int(num)-1] = int(size)

    
#_______________________________________________
class big_title:

  def __init__(self,text,effect=None):  
    self.text   = text
    self.effect = effect

  def display(self,column_desc):
    l=0
    for col in range(column_desc.column_nb):
      l += (column_desc.column_sizes[col]+3)
    l -= (len(self.text) +3)
    
    line = ''    
    for i in range(int(column_desc.shift)): line+=' '		
    line+="| "
    start = int(l)/2
    end   = int(l)-start
    
    if self.effect != None:
      line+=self.effect+bold+reverse
    for i in range(start): line+=" "
    line+=self.text
    for i in range(end): line+=" " 
    line+=endeffect
    line+=" |"   
    print line  
#_______________________________________________
class separator_line:

  def __init__(self,extreme,separator,previous_line=None):  
    self.extreme    = extreme  
    self.separator  = separator
    self.separators = []
    if previous_line == None: return
      
    const = constants()    
    self.separators.append(extreme)
    skip=True
    for col in previous_line.column:
      if skip==True: 
        skip=False
	continue
      if col == const.joined_column(): self.separators.append('_')
      else:                            self.separators.append(separator)
    self.separators.append(extreme) 
    
  def display(self,column_desc):

    const = constants()
    line = ''    
    for i in range(int(column_desc.shift)): line+=' '
    
    if len(self.separators) != 0:
      for c in range(column_desc.column_nb):
	line += self.separators[c]
	line+='_'	
	for ci in range(int(column_desc.column_sizes[c])): line+='_'	
	line+='_' 
      line+=self.extreme 
      print line
      return       
    
    first=True
    for c in range(column_desc.column_nb):
      if first == True:
        # 1rst line begins with extreme separator
        first = False
	line += self.extreme
      else:	
        # Not a fisrt line
	line += self.separator
      line+='_'	
      for ci in range(int(column_desc.column_sizes[c])): line+='_'	
      line+='_' 
    line+=self.extreme   
    print line    
#_______________________________________________
class display_element:

  def __init__(self,value,effect=None):  
    self.value  = value 
    self.effect = effect
     

#_______________________________________________
class display_line:

  def __init__(self,centered=False):  
    self.column     = []   
    self.centered   = centered
      
  def set_column(self,column,value,effect=None):
    # Extend column number
    if int(column) > len(self.column):
      for i in range(len(self.column),int(column)):
        self.column.append(display_element(''))
    self.column[int(column)-1] = display_element(value,effect)

  def check_column(self,column,value):
    # Extend column number
    if int(column) > len(self.column): return False
    if self.column[int(column)-1].value == value: return True
    return False
    
  # Join a colum with its preceding column  
  def join_preceding_column(self,column):
    const = constants()
    # Extend column number
    if int(column) > len(self.column):
      for i in range(len(self.column),int(column)):
        self.column.append(display_element(''))
    self.column[int(column)-1] = display_element(const.joined_column())

  def display(self,column_desc):
    const = constants()
    line=''	
    for i in range(int(column_desc.shift)): line+=' '		
    line+="| "
    for col in range(column_desc.column_nb):
    
      try:     elt=self.column[col]
      except:  elt=display_element('')	
      
      val = elt.value
      eff = elt.effect
      
      if val == const.joined_column(): continue

      l = column_desc.column_sizes[col]-len(val)
      joined = 0
      for jc in range(col+1,column_desc.column_nb):
        try:    next = self.column[jc].value
	except: next = ''
        if next != const.joined_column(): break
	l += column_desc.column_sizes[jc]+3
	joined += 1	
      if self.centered == True:
	start = int(l)/2
	end   = int(l)-start
      else:
	try:
	  float(val)	  
          start=l
	  end=0
	except:
	  start = 0
	  end = l
          
      if eff != None: line+=eff+bold+reverse
      for i in range(start): line+=" "
      line+=val
      for i in range(end): line+=" " 
      line+=endeffect
      line+=" | "  
      col+=joined 
    print line
        
#_______________________________________________
class adaptative_tbl:

  def __init__(self, shift, title=None,effect=None):  
    self.row_nb      = int(0)
    self.row         = [] 
    self.current_row = None 
    self.column_desc = column_desc(shift)   
    if title == None: 
      self.separator(' ',' ')      
    else:
      self.separator(' ','_')
      self.row.append(big_title(title,effect)) 
      self.row_nb += 1
      self.separator('|','_')
    
  def add_line(self,centered):
    line = display_line(centered)
    self.row.append(line) 
    self.row_nb += 1
    self.current_row = line
    
  def new_line(self):    self.add_line(False)
  def new_center_line(self): self.add_line(True)
  
  def separator(self,extreme,separator):
    self.row.append(separator_line(extreme,separator,self.current_row)) 
    self.row_nb = int(self.row_nb)+1
    self.current_row = None
            
  def end_separator(self): self.separator('|','|')	 
         
  def set_column(self,column,value,effect=None):
    value="%s"%(value)
    self.current_row.set_column(column,value,effect)
    self.column_desc.update_column(column,len(strip_ANSI(value)))   
       
  def join_preceding_column(self,column):
    self.current_row.join_preceding_column(column)
                	
  def display(self):
    # Must we add and end separator ?
    if self.current_row != None: self.end_separator()  
    for row in range(int(self.row_nb)):              
      self.row[row].display(self.column_desc)
      previous_line=self.row[row]


ansi_escape = re.compile(r'\x1B[@-_][0-?]*[ -/]*[@-~]')
#__________________________________________________
#
#  Run a command with json output 
#
def get_json_command_result(cmd,isColored=False,debug=False) :

  if debug == True: print cmd
  res1 = subprocess.check_output(cmd, shell=True)
  if debug == True: print res1

  if isColored == True: res1 = ansi_escape.sub('', res1)

  res1 = (json.loads(res1))
  return res1

from optparse import OptionParser

#__________________________________________________
# Check whether all values are equal or some values
# are bad
#
def set_error(storage,error):
  err = errors.get(storage)
  if err == None:
    errors[storage] = error
  else:
    errors[storage] = err + "+" + error 

#__________________________________________________
# Check whether all values are equal or some values
# are bad
#
def check_equality(grp,error):

  #
  # Check whether every values are equal
  #            
  ref = 'X'

  for i in range(2):
    bad_val = []
    good_val = []
    for storage in storage_list:

      val = grp.get(storage) 
      if val == None: continue

      if ref == 'X': 
        ref = val
        good_val.append(storage)
        continue

      if val == ref: 
        good_val.append(storage)
        continue   
      bad_val.append(storage)

    #
    # No bad value
    #
    if len(bad_val) == int(0): return None

    #
    # Some bad values
    #  
    if len(good_val) > len(bad_val): break

    #
    # Lots of bad values. Change good reference
    #  
    if int(i) != int(0): break
    
    ref =  grp.get(bad_val[0])
    del bad_val[:]
    del good_val[:]

  for storage in bad_val: set_error(storage,error)
  return bad_val
#__________________________________________________
# Check whether all values are equal or some values
# are bad
#
def check_different(grp, ref, error):
  
  for storage in storage_list:
    val = grp.get(storage) 
    if val != ref: continue   
    set_error(storage,error)

#__________________________________________________
# Display results for one sub-sfile
#
def display_one_sub_file(rg,slave):
  global fidChunk
  no_error = True
  first_consistent_bid = None
  
  start = int(rg.split(':')[0])
  stop  = int(rg.split(':')[1])
 
  if fidChunk == None: return 0
  if len(timestamps) == 0: return 0
  
  splitted = fidChunk.split('-')
  chk = int(splitted[5])
  fid = "%s-%s-%s-%s-%s"%(splitted[0],splitted[1],splitted[2],splitted[3],splitted[4])

  fname = "SUBFILE[%s] BID[%s] CHUNK[%s]"%(slave,rg,chk)

  #
  # Create result table
  #
  d = adaptative_tbl(2,fname,cyan+bold)
  d.new_center_line()
        
  #
  # Put 1rst line title (storage names)
  # 
  d.set_column(1,"BID")
  idx = int(2)
  for storage in storage_list:
    d.set_column(idx,storage)
    idx += int(1)
  d.set_column(idx,"MISS")
  d.new_center_line()

  if len(storage_list) == 0:
    print "      - CHUNK %s BID %20s : No projections"%(chk,rg)
    d = None
    return 0

  #
  # Put 2nd line title (host names)
  #   
  idx = int(2)
  for host in host_list:
    d.set_column(idx,host)
    idx += int(1)      
  d.set_column(idx,"")
  d.end_separator()     

  consitent_blocks = int(0)

  #
  # Loop on block ids
  #   
  for bid in range(start,stop+1):
    #
    # Get dicts for this block id
    #
    bidPrj    = projections.pop(bid,None)
    if bidPrj == None: continue  
    
    bidTs     = timestamps.pop(bid,None)
    bidCrc32  = checksums.pop(bid,None)
    bidSize   = blksizes.pop(bid,None)

    # 
    # Prepare error dict
    #
    errors.clear()

    #
    # Check every projection is present
    #
    prjList = [0,1,2,3,4,5]
    MISS = ""
    for storage in storage_list:
      try: prjList.remove(bidPrj.get(storage))
      except: pass
    if len(prjList) != int(0):
      if len(prjList) != int(5) and 0 not in prjList:
        beg=""
        for prj in prjList: 
          MISS += "%s%s"%(beg,prj)
          beg=","

    #
    # Check every CRC32 is correct
    #            
    check_different(bidCrc32,"ERROR","CRC")  

    #
    # Check every blocksize are equal
    #            
    check_equality(bidSize,"SZ")        
        
    #
    # Check all time stamps are equal
    # 
    check_equality(bidTs,"TS")            
      
    #
    # Must this bid be display when only errors are to be displayeds
    #   
    if MISS  == "" and len(errors) == int(0):
      if options.error_only == True: 
        consitent_blocks += int(1)
        if first_consistent_bid == None:
          first_consistent_bid = bid
        continue      
    else:  
      no_error = False

    if consitent_blocks != int(0):
      d.new_center_line()
      d.set_column(1,first_consistent_bid)     
      d.set_column(2,"%s consistent blocks"%(consitent_blocks))
      idx = int(3)    
      for storage in storage_list:
        d.join_preceding_column(idx) 
        idx += 1
      consitent_blocks = int(0)
      first_consistent_bid = None              
    #
    # Add new line in the result array
    #
    d.new_line()  
    d.set_column(1,bid)           
    idx = int(2)    
    for storage in storage_list:
      error = errors.get(storage)
      if error != None: 
        d.set_column(idx,"%s %s %s"%(bidPrj.get(storage),bidTs.get(storage),error),red)
      else:  
        if bidPrj.get(storage) == None and bidTs.get(storage) == None:
          d.set_column(idx,"")   
        else:          
          d.set_column(idx,"%s %s "%(bidPrj.get(storage),bidTs.get(storage)))   
      idx += 1
    d.set_column(idx, MISS)
    
  #
  # Display the result table
  #  
  
  if options.error_only == True and no_error == True:
    print "      - CHUNK %s BID %20s : %s consistent blocks"%(chk,rg,consitent_blocks)
    d = None
    return 0
    
  if consitent_blocks != int(0):
    d.new_center_line()
    d.set_column(1,first_consistent_bid)     
    d.set_column(2,"%s consistent blocks"%(consitent_blocks))
    idx = int(3)    
    for storage in storage_list:
      d.join_preceding_column(idx) 
      idx += int(1)

  d.display()
  d = None
  if no_error == True: return 0
  return 1

#__________________________________________________
# Parse one sub-sfile
#
def parse_one_projection_rozodump(f,chunk,rg):
  global fidChunk
  #
  # Do not care about header files
  #
  if "/hdr_" in f['name']: return
  
  #
  # Split file name to get fid, sid name and path
  #  
  splitted = f['name'].split('/')
  fid = splitted[len(splitted)-1]
  chk = int(fid.split('-')[5])
  if chk != int(chunk): return
  fidChunk = fid
  storage = splitted[len(splitted)-5]
  if not storage in storage_list: 
    storage_list.append(storage)
    host_list.append(f['host'])
  path=""
  for i in range(len(splitted)-5): path += "/%s"%(splitted[i+1])

  #print "parse chunk %s %s %s"%(chunk,path,fid)

  #
  # Call rozodump via ssh to dump the block headers
  #
  cmd = "ssh %s \'%s -p %s -f %s -b %s -s\'"%(f['host'],DUMP,path,fid,rg)  
  if options.debug == True: print cmd

  parsed = shlex.split(cmd)
  cmd = subprocess.Popen(parsed, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
  for line in cmd.stdout:    

    #
    # Display the rozodump output when not only error
    #
    #if options.debug == True: sys.stdout.write(line)

    #
    # Parse bid, prj, crc32 and time stamp 
    L = ansi_escape.sub('', line)
    LSplit = L.split('|')
    try:
      bid    = int(LSplit[1])
    except:
      continue
    prj    = int(LSplit[4])
    size   = int(LSplit[5])
    crc32  = LSplit[6].strip()
    if LSplit[7].strip() == "Empty":
      ts = int(0)
    else:   
      ts = int(LSplit[7].split()[3])

    #
    # Get timestamp, projections and checksum dicts for this block id
    #
    bidTs     = timestamps.get(bid)
    bidPrj    = projections.get(bid)
    bidCrc32  = checksums.get(bid)
    bidSize   = blksizes.get(bid)

    if bidTs == None:
      #
      # Have to create one
      #
      timestamps[bid]  = {storage:ts}
      projections[bid] = {storage:prj}
      checksums[bid]   = {storage:crc32}
      blksizes[bid]    = {storage:size}
    else:  
      # 
      # Update the dicts
      #
      timestamps[bid].update({storage:ts})
      projections[bid].update({storage:prj})
      checksums[bid].update({storage:crc32})
      blksizes[bid].update({storage:size})

#_________________________
# Cleanup dicts and list
#
def cleanup_dicts():
  global storage_list, host_list, timestamps, checksums, projections, blksizes
  del storage_list[:]
  del host_list[:]
  timestamps.clear()
  checksums.clear()
  blksizes.clear()
  projections.clear() 
#_________________________
# Display syntax and exit
#
def syntax(string=None):

  if string != None:
    print "\n" + red + bold + string + " !!!" + endeffect + "\n"
    
  print "Usage: " 
  print "      "+ bold + "rozo_file_consistency -a [ -n <mount point> ] "+ endeffect
  print "         To check consistency of every RozoFS file having experienced a write error under eid designated by -n, ."
  print "         When -n is not set, local path is used.\n"
  print "      "+ bold + "rozo_file_consistency -n <file> [-s <subfile>] [-b <bid>] [-e]"+ endeffect
  print "         To check consistency of RozoFS file designated by -n."
  print "         When -e is set all blocks are displayed, and not only those in error."
  print "         -s <sub file> limits the examination to the given subfile."
  print "         -b <bids> limits the examination to the given blocks. <bids> format is"
  print "             <1rst>:<last> or :<last> or <first>: or <one bid>"
  print ""
  print "examples:"
  print "  To check all file of an eid"
  print "    cd /mnt/rfs; rozo_file_consitency -a"
  print "    rozo_file_consitency -a -n  /mnt/rfs"
  print "  To check one file"  
  print "    rozo_file_consitency -n /mnt/rfs/project/badFile"
  print "  To examine in details a portion of a file"    
  print "    rozo_file_consitency -n /mnt/rfs/project/badFile -e -s 0 -b 1000:2000   (from block 1000 to 2000)"
  print "    rozo_file_consitency -n /mnt/rfs/project/badFile -e -s 0 -b 156         (only block 156)"
  print "    rozo_file_consitency -n /mnt/rfs/project/badFile -e -s 0 -b :20         (from block 0 to 20)"
  print "    rozo_file_consitency -n /mnt/rfs/project/badFile -e -s 0 -b 1250:       (from block 1250 to the end)"
  
  sys.exit(-1)
#_________________________
# Process on subfile 
#
def process_one_subfile(slave,rsp):
  global fidChunk, block_start, block_stop

  print "  * subfile %s FID %s"%(slave,fid_list[slave]) 
  blkPerChunk = int(16*1024*1024)
  maxLoop     = int(256)
  blkPerLoop  = int(blkPerChunk/maxLoop)

  res = int(0)
  offset = - blkPerLoop
  
  for chunk in range(128):

    fidChunk = None
    for loop in range(maxLoop):

      cleanup_dicts()
      offset += blkPerLoop
      
      start = offset
      stop  = offset+blkPerLoop-1
      
      if int(start) > int(block_stop):  break
      if int(stop) < int(block_start): continue
      
      if int(start) < int(block_start): rg = "%s"%(block_start)
      else:                             rg = "%s"%(start)
      rg += ":"
      if int(stop) > int(block_stop): rg += "%s"%(block_stop)
      else:                           rg += "%s"%(stop)
            
      for f in rsp['files']:
        if "/hdr_" in f['name']: continue
        bidMax =  int(f['size'])/int(1048) + (blkPerChunk*chunk)
        if bidMax > offset: 
          parse_one_projection_rozodump(f,chunk,rg) 
      res += display_one_sub_file(rg,slave)

  return res
#_________________________
# Cleanup dicts and list
#
def get_version(response):

  try:
    v3format = response['files'][0]
    fid_list.append(response['fid'])
    return int(3), int(1)
  except:
    pass

  count = int(0)
  for i in range(10):
    try:
      v4format = response['slaves'][i]
      fid_list.append(response['slaves'][i]['fid'])
      count += int(1)
    except:
      pass
     
  if count != int(0):
    return int(4), count
        
  syntax("Unexpected rozo_locate_projections output format")
#_________________________
# Scan every file having experieced a write error
#
def inspect_all_write_errors():

  count          = int(0)
  mount_instance = None
  eid            = None

  #
  # Get the eid to inspect from local path
  # or given name using a get attribute API
  if options.fname == None: 
    name = os.getcwd()
  else:
    name = options.fname      
  cmd = "attr -qg rozofs.export %s"%(name)        
  parsed = shlex.split(cmd)
  cmd = subprocess.Popen(parsed, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
  for line in cmd.stdout:    
    try:
      eid = int(line.split()[1])
      mount_instance = int(line.split()[3])
      break
    except:
      syntax ("\"%s\" is not a RozoFS path."%(name))
  if mount_instance == None:
    syntax ("\"%s\" is not a RozoFS path."%(name)) 

  #
  # Get the mount path from the rozofsmount via rozodiag
  #  
  path = None
  cmd = "%s -T mount:%s -c mount"%(DIAG,mount_instance)
  parsed = shlex.split(cmd)
  cmd = subprocess.Popen(parsed, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
  for line in cmd.stdout:    
    values = line.split()
    if values[0] != "mount" : continue
    path = values[2]
    break
    
  if path == None:
    syntax ("Can not get mount path \"%s\""%(cmd))

  #
  # Get lis of files having experienced a write error using rozo_scan
  #
  print "Scanning files under eid %s having experienced a write error."%(eid)
  cmd = "%s e %s w"%(SCAN,eid)
  parsed = shlex.split(cmd)
  cmd = subprocess.Popen(parsed, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
  for f in cmd.stdout:  
    os.system("rozo_file_consistency -n %s/%s"%(path,f)) 
    count += int(1)
    
  if count == int(0):    
    print "No file to process"
  elif count == int(1): 
    print "1 file found"
  else:   
    print "%s files found"%(count) 
  sys.exit(0)    

#__________________________________________________
# Find whether a program is defined
#
def which(pgm):
  path=os.getenv('PATH')
  for p in path.split(os.path.pathsep):
    p=os.path.join(p,pgm)
    if os.path.exists(p) and os.access(p,os.X_OK):
      return pgm   
  syntax("utility %s not found"%(pgm))  
#__________________________________________________
# 
# M A I N
#
#__________________________________________________
parser = OptionParser()
parser.add_option("-n","--name", action="store",type="string", dest="fname", help="Targeted file name")
parser.add_option("-b","--block", action="store",type="string", dest="block", help="Block to check")
parser.add_option("-s","--slave", action="store",type="string", dest="slave", default=None,help="Slave file index")
parser.add_option("-e","--error", action="store_false",default=True, dest="error_only", help="Do not only display errors.")
parser.add_option("-d","--debug", action="store_true",default=False, dest="debug", help="Debug mode.")
parser.add_option("-a","--all", action="store_true",default=False, dest="all", help="Inspect all files having experienced a write error.")
(options, args) = parser.parse_args()

#
# Test environment ?
#
ROZO_PATH = os.getenv("ROOT_ROZO")
if ROZO_PATH != None:
  LOCATE = ROZO_PATH + "/tests/build/src/rozofsmount/rozo_locate_projections"
  DUMP   = ROZO_PATH + "/tests/build/src/storaged/rozodump"
  SCAN   = ROZO_PATH + "/src/rozofsmount/rozo_scan"
  DIAG   = ROZO_PATH + "/tests/build/src/rozodiag/rozodiag"
else:  
  LOCATE = "rozo_locate_projections"
  DUMP   = "rozodump"
  DIAG   = which("rozodiag")
  SCAN   = which("rozo_scan")

if options.all == True:
  inspect_all_write_errors()
  
    
if options.fname == None:
  syntax("Either -a or -n option must be set.")

if os.path.isfile(options.fname) == False:
  syntax( "\"%s\" is not a file"%(options.fname))

if options.block == None:
  block_start = int(0)
  block_stop = int(1000000000000000)  
else:  
  if ':' in options.block:
    try:
      block_start = int(options.block.split(':')[0])
    except:
      block_start = int(0)
    try:
      block_stop = int(options.block.split(':')[1])
    except:
      block_stop = int(1000000000000000)
  else:
    try:
      block_start = int(options.block)
      block_stop  = block_start
    except:    
      syntax("Invalid block option")
      
response = get_json_command_result("%s -n \"%s\""%(LOCATE,options.fname),isColored=True,debug=options.debug)

timestamps   = {}
checksums    = {}
projections  = {}
blksizes     = {}
errors       = {}
storage_list = []
host_list = []
fid_list = []
exit_code = 0

#
# determine RozoFS version from response format
#
release, subfiles = get_version(response)

if subfiles == int(1):
  print underline + options.fname + endeffect + " : 1 subfile"
else:
  print underline + options.fname + endeffect + " : %s subfiles"%(subfiles) 
fname=""


#
# Release 3 only one subfile
#
if release == int(3): 
  exit_code = process_one_subfile(0,response)
  sys.exit(exit_code)  

#
# Release 4 Up to 8 subfiles
#
slaveNb = int(-1)
for slave in response['slaves']:

  slaveNb  = slaveNb + int(1)
  if options.slave != None:
    if int(options.slave) != int(slaveNb): continue
  exit_code += process_one_subfile(slaveNb,slave)
sys.exit(exit_code)  
