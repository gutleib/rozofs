#!/usr/bin/python
# -*- coding: utf-8 -*-
# Copyright (c) 2010 Fizians SAS. <http://www.fizians.com>
# This file is part of Rozofs.
#
# Rozofs is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 2.
#
# Rozofs is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see
# <http://www.gnu.org/licenses/>.
import sys
import os.path
import subprocess
import time
import re
import shlex
red = '\033[91m'
green = '\033[92m'
yellow = '\033[93m'
blue = '\033[94m'
purple = '\033[95m'
cyan = '\033[96m'
white = '\033[97m'
endeffect = '\033[0m'
bold = '\033[1m'
underline = '\033[4m'
blink = '\033[5m'
reverse = '\033[7m'


strip_ANSI_pat = re.compile(r"""
    \x1b     # literal ESC
    \[       # literal [
    [;\d]*   # zero or more digits or semicolons
    [A-Za-z] # a letter
    """, re.VERBOSE).sub

def strip_ANSI(s):
    return strip_ANSI_pat("", s)

#_______________________________________________
class constants:

  def joined_column(self): return "#Zis_IZ_a_JoInED_ColUMn"
  
#_______________________________________________
class column_desc:

  def __init__(self,shift):  
    self.column_nb    = 0
    self.column_sizes = []
    self.shift        = shift
     
  def update_column(self, num, size):
  
    # Column number extension
    if int(num) > self.column_nb:
      for i in range(self.column_nb,num):
        self.column_sizes.append('0')
      self.column_nb = num 	
	
    # Column size extension
    if int(self.column_sizes[int(num)-1]) < int(size):
      self.column_sizes[int(num)-1] = int(size)

    
#_______________________________________________
class big_title:

  def __init__(self,text,effect=None):  
    self.text   = text
    self.effect = effect

  def display(self,column_desc):
    l=0
    for col in range(column_desc.column_nb):
      l += (column_desc.column_sizes[col]+3)
    l -= (len(self.text) +3)
    
    line = ''    
    for i in range(int(column_desc.shift)): line+=' '		
    line+="| "
    start = int(l)/2
    end   = int(l)-start
    
    if self.effect != None:
      line+=self.effect+bold+reverse
    for i in range(start): line+=" "
    line+=self.text
    for i in range(end): line+=" " 
    line+=endeffect
    line+=" |"   
    print line  
#_______________________________________________
class separator_line:

  def __init__(self,extreme,separator,previous_line=None):  
    self.extreme    = extreme  
    self.separator  = separator
    self.separators = []
    if previous_line == None: return
      
    const = constants()    
    self.separators.append(extreme)
    skip=True
    for col in previous_line.column:
      if skip==True: 
        skip=False
	continue
      if col == const.joined_column(): self.separators.append('_')
      else:                            self.separators.append(separator)
    self.separators.append(extreme) 
    
  def display(self,column_desc):

    const = constants()
    line = ''    
    for i in range(int(column_desc.shift)): line+=' '
    
    if len(self.separators) != 0:
      for c in range(column_desc.column_nb):
	line += self.separators[c]
	line+='_'	
	for ci in range(int(column_desc.column_sizes[c])): line+='_'	
	line+='_' 
      line+=self.extreme 
      print line
      return       
    
    first=True
    for c in range(column_desc.column_nb):
      if first == True:
        # 1rst line begins with extreme separator
        first = False
	line += self.extreme
      else:	
        # Not a fisrt line
	line += self.separator
      line+='_'	
      for ci in range(int(column_desc.column_sizes[c])): line+='_'	
      line+='_' 
    line+=self.extreme   
    print line    
#_______________________________________________
class display_element:

  def __init__(self,value,effect=None):  
    self.value  = value 
    self.effect = effect
     

#_______________________________________________
class display_line:

  def __init__(self,centered=False):  
    self.column     = []   
    self.centered   = centered
      
  def set_column(self,column,value,effect=None):
    # Extend column number
    if int(column) > len(self.column):
      for i in range(len(self.column),int(column)):
        self.column.append(display_element(''))
    self.column[int(column)-1] = display_element(value,effect)

  def check_column(self,column,value):
    # Extend column number
    if int(column) > len(self.column): return False
    if self.column[int(column)-1].value == value: return True
    return False
    
  # Join a colum with its preceding column  
  def join_preceding_column(self,column):
    const = constants()
    # Extend column number
    if int(column) > len(self.column):
      for i in range(len(self.column),int(column)):
        self.column.append(display_element(''))
    self.column[int(column)-1] = display_element(const.joined_column())

  def display(self,column_desc):
    const = constants()
    line=''	
    for i in range(int(column_desc.shift)): line+=' '		
    line+="| "
    for col in range(column_desc.column_nb):
    
      try:     elt=self.column[col]
      except:  elt=display_element('')	
      
      val = elt.value
      eff = elt.effect
      
      if val == const.joined_column(): continue

      l = column_desc.column_sizes[col]-len(val)
      joined = 0
      for jc in range(col+1,column_desc.column_nb):
        try:    next = self.column[jc].value
	except: next = ''
        if next != const.joined_column(): break
	l += column_desc.column_sizes[jc]+3
	joined += 1	
      if self.centered == True:
	start = int(l)/2
	end   = int(l)-start
      else:
	try:
	  float(val)	  
          start=l
	  end=0
	except:
	  start = 0
	  end = l
          
      if eff != None: line+=eff+bold+reverse
      for i in range(start): line+=" "
      line+=val
      for i in range(end): line+=" " 
      line+=endeffect
      line+=" | "  
      col+=joined 
    print line
        
#_______________________________________________
class adaptative_tbl:

  def __init__(self, shift, title=None,effect=None):  
    self.row_nb      = int(0)
    self.row         = [] 
    self.current_row = None 
    self.column_desc = column_desc(shift)   
    if title == None: 
      self.separator(' ',' ')      
    else:
      self.separator(' ','_')
      self.row.append(big_title(title,effect)) 
      self.row_nb += 1
      self.separator('|','_')
    
  def add_line(self,centered):
    line = display_line(centered)
    self.row.append(line) 
    self.row_nb += 1
    self.current_row = line
    
  def new_line(self):    self.add_line(False)
  def new_center_line(self): self.add_line(True)

  def new_title_line(self,title,effect=None): 
    self.separator('|','|')
    self.row.append( big_title(title,effect)) 
    self.row_nb += 1
    self.current_row = None
  
  def separator(self,extreme,separator):
    self.row.append(separator_line(extreme,separator,self.current_row)) 
    self.row_nb = int(self.row_nb)+1
    self.current_row = None
            
  def end_separator(self): self.separator('|','|')	 
  def title_separator(self): self.separator('|','_')	 
         
  def set_column(self,column,value,effect=None):
    value="%s"%(value)
    self.current_row.set_column(column,value,effect)
    self.column_desc.update_column(column,len(strip_ANSI(value)))   
       
  def join_preceding_column(self,column):
    self.current_row.join_preceding_column(column)
                	
  def display(self):
    # Must we add and end separator ?
    if self.current_row != None: self.end_separator()  
    for row in range(int(self.row_nb)):              
      self.row[row].display(self.column_desc)
      previous_line=self.row[row]



clusters = []

#____________________________________
# Class sid
#____________________________________
class cluster:
  def __init__(self, cid): 
    self.cid = cid
    self.nbFiles = 0
    self.sidMax = 0
    self.inverse=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    self.forward=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    self.spare=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    clusters.append(self)
  	
  @staticmethod
  def get_cluster(cid):
    global clusters
    for c in clusters: 
	  if cid == c.cid: return c
    cluster(cid)
    for c in clusters: 
	  if cid == c.cid: return c	  
    return None
	
  def add_file(self,dist):
    global sidMax
    self.nbFiles = self.nbFiles + 1
    nb=int(0)
    for id in dist.split('-'):
      id=int(id)
      if id > self.sidMax: self.sidMax = id
      if id > sidMax: sidMax = id
      if nb<inv :  
        self.inverse[id] = self.inverse[id] +1
      if nb<fwd :  
        self.forward[id] = self.forward[id] +1
      if nb>=fwd : 
        self.spare[id] = self.spare[id] +1
      nb=nb+1
      
  @staticmethod
  def display_cluster():  
    sc = sorted(clusters, key=lambda cluster: cluster.cid)
    d = adaptative_tbl(2,"DISTRIBUTION ON %s CLUSTERS"%(len(clusters)),cyan+bold)
    d.new_center_line()
    d.set_column(1,"SID")
    for s in range(sidMax):
      sid = "%s"%(s+1)
      col = s + int(2)
      d.set_column(col,sid)

    d.new_title_line("occurences within the 1rst %s in distribution(read)"%(inv),white)
    d.title_separator()
    
    for c in  sc: 	
      d.new_line()
      d.set_column(1,"CID %s"%(c.cid))
      for s in range(sidMax):
        sid = (s+1)
        col = s + int(2)
        d.set_column(col,c.inverse[sid])             

    d.new_title_line("occurences within the 1rst %s in distribution(write)"%(fwd),white)
    d.title_separator()

    for c in  sc: 	
      d.new_line()
      d.set_column(1,"CID %s"%(c.cid))
      for s in range(sidMax):
        sid = (s+1)
        col = s + int(2)
        d.set_column(col,c.forward[sid])             

    d.new_title_line("occurences within the last %s in distribution(spare)"%(safe-fwd),white)
    d.title_separator()

    for c in  sc: 	
      d.new_line()
      d.set_column(1,"CID %s"%(c.cid))
      for s in range(sidMax):
        sid = (s+1)
        col = s + int(2)
        d.set_column(col,c.spare[sid])             
    d.display()


#__________________________________________________
# Find whether a program is defined
#
def which(pgm):
  path=os.getenv('PATH')
  for p in path.split(os.path.pathsep):
    p=os.path.join(p,pgm)
    if os.path.exists(p) and os.access(p,os.X_OK):
      return pgm   
  syntax("utility %s not found"%(pgm))      
#___________________________________________    

if len(sys.argv) < 2:
  path=os.getcwd()
else:
  path=sys.argv[1]
  if path[0] != '/':path="%s/%s"%(os.getcwd(),path)
path=os.path.abspath(path)


# Check attr utility exist
which("attr")

layout=255
string="attr -g rozofs %s"%(path)
parsed = shlex.split(string)
cmd = subprocess.Popen(parsed, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
for line in cmd.stdout:
  if not "LAYOUT" in line: continue
  layout=int(line.split(':')[1])
  break
  
if layout == 255:
  print "%s seems not to be a mounted RozoFS path"%(path) 
  sys.exit(1)
   
if layout == 0:
  inv=2
  fwd=3
  safe=4
elif layout == 1:     
  inv=4
  fwd=6
  safe=8
elif layout == 2:
  inv=8
  fwd=12
  safe=16
  
nbFiles    = int(0)
nbSubFiles = int(0)
  
sidMax = int(0)

for f in os.listdir(path):  

  isFile  = False

  string="attr -g rozofs %s/%s"%(path,f)
  parsed = shlex.split(string)
  cmd = subprocess.Popen(parsed, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

  for line in cmd.stdout:

    if isFile == False:
      try:
        if line.split()[0] != "MODE": continue
        if line.split()[2] != "REGULAR": break
        isFile = True
        nbFiles += int(1)
        cid = int(0)
      except: pass
      continue
        
    if "CLUSTER" in line: 
      cid = int(line.split(':')[1])
      continue
           
    if not "STORAGE" in line: continue
    if cid == int(0): continue           
    
    dist = line.split(':')[1]
    c = cluster.get_cluster(cid)
    c.add_file(dist)
    nbSubFiles += int(1)

print "%s files / %s subfiles under %s"%(nbFiles,nbSubFiles,path)
cluster.display_cluster()
