#!/usr/bin/python
# -*- coding: utf-8 -*-
# Copyright (c) 2010 Fizians SAS. <http://www.fizians.com>
# This file is part of Rozofs.
#
# Rozofs is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 2.
#
# Rozofs is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see
# <http://www.gnu.org/licenses/>.
import sys
import os.path
import subprocess
import time
import re
import shlex
import datetime
import shutil

from optparse import OptionParser

devices = []

active_export = None
UP_LINE = ""
BOTTOM_LINE = ""
#___________________________
# converts string <inBytes> to integer 
# in the unit given by <to>.
# <inBytes>  is 
# [<spaces>]<numeric>[{.|,}<numeric>][<spaces>]<unit>
# <unit> is {B|K|KB|M|MB|G|GB|T|TB|P|PB}
# <to> is <unit>
def common_convert_Bytes(inBytes,to="B"):
  inBytes = inBytes.replace(" ", "")

  if "." in inBytes:
    before = int(inBytes.split('.')[0])
    after  = inBytes.split('.')[1]
    unit   = re.split('(\d+)',after)[2]
    after  = re.split('(\d+)',after)[1]
  elif "," in inBytes:
    before = int(inBytes.split(',')[0])
    after  = inBytes.split(',')[1]
    unit   = re.split('(\d+)',after)[2]
    after  = re.split('(\d+)',after)[1]
  else:
    unit   = re.split('(\d+)',inBytes)[2]
    before = re.split('(\d+)',inBytes)[1]
    after = "0"

  if   len(after) == 1: after=int(after)*100
  elif len(after) == 2: after=int(after)*10
  elif len(after) == 3: after=int(after)

  if   unit == "KB" or unit == "K": val = (int(before)*1000 + after)
  elif unit == "MB" or unit == "M": val = (int(before)*1000 + after) * 1000
  elif unit == "GB" or unit == "G": val = (int(before)*1000 + after) * 1000000
  elif unit == "TB" or unit == "T": val = (int(before)*1000 + after) * 1000000000
  elif unit == "PB" or unit == "P": val = (int(before)*1000 + after) * 1000000000000
  else: val = int(before)
  
  if to == "B":              return val
  if to == "K" or to =="KB": return val/1000
  if to == "M" or to =="MB": return val/1000000  
  if to == "G" or to =="GB": return val/1000000000
  if to == "T" or to =="TB": return val/1000000000000
  if to == "P" or to =="PB": return val/1000000000000000
  return val
#______________________  
def common_bytes_with_unit(inBytes):
  if inBytes < 0: sign = "-"
  else:           sign = ""
  
  string="%s"%(inBytes)
  value = common_convert_Bytes(string,"B")

  if value < 1000: return "%s%4d  "%(sign,value)
  
  if value < 1000000:
    if value >= (100*1000): return "%s%4d K"%(sign,value/1000)
    if value >=  (10*1000): return "%s%2d.%1d K"%(sign,value/1000,(value % 1000) / 100)
    return "%s%1d.%2.2d K"%(sign,value/1000,(value % 1000) / 10)   
  
  if value < 1000000000:  
    if value >= (100*1000000): return "%s%4d M"%(sign,value/1000000)
    if value >=  (10*1000000): return "%s%2d.%1d M"%(sign,value/1000000,(value % 1000000) / 100000)
    return "%s%1d.%2.2d M"%(sign,value/1000000,(value % 1000000) / 10000)   
  
  if value < 1000000000000:  
    if value >= (100*1000000000): return "%s%4d G"%(sign,value/1000000000)
    if value >=  (10*1000000000): return "%s%2d.%1d G"%(sign,value/1000000000,(value % 1000000000) / 100000000)
    return "%s%1d.%2.2d G"%(sign,value/1000000000,(value % 1000000000) / 10000000)   
  
  if value < 1000000000000000:  
    if value >= (100*1000000000000): return "%s%4d T"%(sign,value/1000000000000)
    if value >=  (10*1000000000000): return "%s%2d.%1d T"%(sign,value/1000000000000,(value % 1000000000000) / 100000000000)
    return "%s%1d.%2.2d T"%(sign,value/1000000000000,(value % 1000000000000) / 10000000000)   
  
  if value < 1000000000000000000:  
    if value >= (100*1000000000000000): return "%s%4d P"%(sign,value/1000000000000000)
    if value >=  (10*1000000000000000): return "%s%2d.%1d P"%(sign,value/1000000000000000,(value % 1000000000000000) / 100000000000000)
  
  return "%s%1s.%2.2d P"%(sign,value/1000000000000000,(value % 1000000000000000) / 10000000000000)   

#______________________________
def is_this_export_active(export):

  string="%s -i %s -T export:1 -c up"%(DIAG,export)
  parsed = shlex.split(string)
  cmd = subprocess.Popen(parsed, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
  for line in cmd.stdout:
      if "uptime" in line:
        return True
  return False
#______________________________
def get_active_export(exports):
  global active_export
  
  #
  # Last active export is given
  # Check it 1rst
  #
  if active_export != None:
    if is_this_export_active(active_export) == True: return active_export
  
  #
  # No last active given
  # or last active no more active (switchover
  #  
  for export in exports.split('/'):

    #
    # The last active is no more active
    #
    if export == active_export: continue
    
    if is_this_export_active(export) == True: 
      active_export = export
      return export
      
  active_export = None
  return None
#______________________________
def get_eid_and_exports_from_path(path):
  eid=None
  string="attr -qg rozofs.export %s"%(path)
  parsed = shlex.split(string)
  cmd = subprocess.Popen(parsed, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
  for line in cmd.stdout:
    exports=line.split()[0]
    eid=line.split()[1]
    instance = int(line.split()[3])
    onlyClient = "-i 127.0.0.1 -T mount:%s "%(instance)
    return eid,exports,onlyClient
  syntax( "%s is not a RozoFS mountpoint"%(path))
            
#______________________________
def check_netmwork_filters(address):

  try:
    ip = get_ip(address)
  except: 
    return False

  if len(NipLowArray) != 0:
    idx = 0
    for low in NipLowArray:
      high = NipHighArray[idx]
      if ip >= low and ip <= high: 
        if options.verbose: print RED+"%s rejected %s"%(address,NipRule[idx])+NORMAL 
        return False
      idx += 1
          
  if len(ipLowArray) != 0:
    idx = 0
    for low in ipLowArray:
      high = ipHighArray[idx]
      if ip >= low and ip <= high: 
        if options.verbose: print GREEN+"%s accepted %s"%(address,ipRule[idx])+NORMAL     
        return True
      idx += 1
  else:
    if options.verbose: print GREEN+"%s accepted"%(address)+NORMAL 
    return True
    
  if options.verbose: print RED+"%s rejected"%(address)+NORMAL 
  return False
  
#______________________________
def get_client_list(exports,eid):
  global total_watched_clients
  global total_nb_clients
  global onlyClient
  
  if options.justThisOne == True: 
    total_watched_clients = 1 
    total_nb_clients = 1
    return onlyClient
  
  total_watched_clients = 0 
  total_nb_clients = 0

  active_export = get_active_export(exports)
  if active_export == None:
    return None
    
  idx = int(eid) % 8
  clients=""
  string="%s -i %s -T export:%s -c client"%(DIAG,active_export,idx)
  parsed = shlex.split(string)
  cmd = subprocess.Popen(parsed, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
  for line in cmd.stdout:
    words = line.split('|')
    try:
      int(words[3])
      delay = int(words[2])
      if delay > int(300) : continue
    except:
      continue  
    total_nb_clients += int(1)
    ip = words[4].split(':')[0]
    if check_netmwork_filters(ip) == False: continue
    port = words[4].split(':')[1]
    # Old versions gives the rozodiag port (starting at 50003
    # New version gives the rozofsmount instance (under 64)
    if int(port) >= int(50003):
      instance = (int(port) - int(50003))/3
    else:
      instance = int(port)  
    string="%s -i %s -T mount:%s -c mount"%(DIAG,ip,instance)
    parsed = shlex.split(string)
    cmd = subprocess.Popen(parsed, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    for line in cmd.stdout:
      if line.split()[0] != "eid": continue
      if line.split()[2] != eid: continue
      clients = clients + " -i %s -T mount:%s"%(ip,instance)     
      total_watched_clients += int(1)  
  return clients      
#______________________________
def get_ip(ipString):
 if len(ipString.split('.')) != 4: int(a)
 ip = int(0)
 for val in ipString.split('.'):
   ip = ip * int(256) + int(val)
 return ip  

#______________________________________    
def get_line_index(val):
  if val == " Avg ": return 10
  try:
    return -int(val) - 1
  except:
    return -1  
#______________________________________    
def get_color_code(col):
  global titles
  
  letter = titles[col][1]
  idx = ord(letter) - ord('A')
#  print "TITLE %s %d"%(letter,idx)
  idx = idx % len(color_list)
  return color_list[idx]
  
#______________________________________    
def build_upline(titles,total_column):
  global UP_LINE
  global BOTTOM_LINE

  UP_LINE = "     "  
  for col in range(total_column):
    UP_LINE = UP_LINE + ' ' + titles[col][0:8].replace(' ','_')
  UP_LINE = UP_LINE + " "
  
  BOTTOM_LINE = "     "
  for column in range(total_column):
    BOTTOM_LINE = BOTTOM_LINE + '|' + "________"
  BOTTOM_LINE = BOTTOM_LINE + '|'  
  
#______________________________________    
def delta_time(minute,sec,minus):
  if int(sec) >= int(minus):
    return int(minute),int(sec)-int(minus)
  if int(minute) > int(0):
    return int(minute)-int(1),int(60)+int(sec)-int(minus)
  return int(59),int(60)+int(sec)-int(minus)    

#______________________________________    
def syntax(string=None):
  if string != None:
    print "\n" + RED + BOLD + string + " !!!" + NORMAL + "\n"
    
  print "Usage: " + BOLD + "rozo_io "+ YELLOW +"[OPTIONS]" + CYAN + " [FILTER] " + GREEN + "[MOUNTPOINT]"+ NORMAL
  print
  print YELLOW +"  OPTIONS = {--period <seconds>|--history}"+ NORMAL
  print YELLOW +"    -p,--period <seconds>"+ NORMAL +"   Enables to set the refresh period to <seconds> seconds."
  print YELLOW +"    -H,--history"+ NORMAL +"            Displays a 60 minutes and a 60 hours history."
  print YELLOW +"    -d,--delay <hours#>"+ NORMAL +"     Run for <hours#> hours."
  print
  print CYAN + "  FILTER = {--ipRange <IP1@-IP2@> ... | --NipRange <IP1@-IP2@> ... | --what <what> ...}"+ NORMAL
  print CYAN + "    -1,--one                 "+ NORMAL  +"  just the client handling the mountpoint." 
  print CYAN + "    -i,--ipRange  <IP1@-IP2@>"+ NORMAL  +"  excludes clients whose IP address is out of IP1-IP2 range." 
  print CYAN + "    -I,--NipRange <IP1@-IP2@>"+ NORMAL  +"  excludes clients whose IP address is within IP1-IP2 range." 
  print CYAN + "    -w,--what {r|w|l|c|d|a|x|o|nr|nw|nl|nc|nd|na|nx|no}"+ NORMAL  
  print        "              what columns to display or not to display. (check rozodiag io CLI of rozofsmount)." 
  print
  print GREEN + "  MOUNTPOINT = <mnt>"+ NORMAL
  print GREEN + "    mnt = "+ NORMAL  +"RozoFS mount point"
  print "  When no mount point is provided, current path is taken as input mount point."
  print 
  print "examples:"
  print "  rozo_io --what r -w w /mnt/rfs1" 
  print "  rozo_io -p 10 /mnt/rfs " 
  print 
  sys.exit(-1)    
  
def test(string):
  val = val = common_convert_Bytes(string)
  print "%20s : %s "%(string,val)
#__________________________________________________
# Find whether a program is defined
#
def which(pgm):
  path=os.getenv('PATH')
  for p in path.split(os.path.pathsep):
    p=os.path.join(p,pgm)
    if os.path.exists(p) and os.access(p,os.X_OK):
      return pgm   
  syntax("utility %s not found"%(pgm))    
#______________________________________    

RED='\033[91m\033[40m\033[1m'
GREEN='\033[92m\033[40m'
DARKGREEN='\033[32m\033[40m'
YELLOW='\033[93m\033[40m'
ORANGE='\033[33m\033[40m'
BLUE='\033[94m\033[40m'
LIGHTBLUE='\033[34m\033[40m\033[1m'
PURPLE='\033[95m\033[40m'
DEEPPURPLE='\033[95m\033[40m\033[1m'
CYAN='\033[96m\033[40m'
WHITE='\033[97m\033[40m'
LIGHTCYAN='\033[36m\033[40m'

BOLD='\033[1m'
REVERSE='\033[7m'
NORMAL='\033[0m'

color_list=[LIGHTBLUE,PURPLE,YELLOW,GREEN , ORANGE , BLUE, WHITE,CYAN,LIGHTCYAN,RED]
time_unit_list=["s","m","h"]

parser = OptionParser()
parser.add_option("-d","--delay", action="store",type="string", dest="delay", help="Delay in hours for periodic mode (default is infinite)")
parser.add_option("-p","--period", action="store",type="string", dest="period", help="Periodicity of the command")
parser.add_option("-v","--verbose", action="store_true",default=False, dest="verbose", help="Verbose mode for debug.")
parser.add_option("-H","--history", action="store_true",default=False, dest="history", help="Display a 60 minutes and 60 hours history of total counters.")
parser.add_option("-P","--PHistory", action="store_true",default=False, dest="Phistory", help="Display a 60 minutes and 60 hours history of per second conuters.")
parser.add_option("-i","--ipRange", action="append",type="string", dest="iprange", help="Allowed IP range (one IP address or a range like 192.168.1.21-192.168.1.28)")
parser.add_option("-I","--NipRange", action="append",type="string", dest="Niprange", help="Rejected IP range (one IP address or a range like 192.168.10.30-192.168.10.50)")
parser.add_option("-w","--what", action="append",type="string", dest="what", help="what to (not to) display \"<r|nr|w|nw|l|nl|c|nc|d|nd|a|na|x|nx|o|no>\" (default everything).")
parser.add_option("-1","--one", action="store_true",default=False, dest="justThisOne", help="Just display the given client.")
parser.add_option("-b","--bold", action="store_false",default=True, dest="bold", help="Do not highlight biggest values.")

total_watched_clients = int(0)
total_nb_clients = int(0)

(options, args) = parser.parse_args()

which("attr")
#
# Test environment ?
#
ROZO_PATH = os.getenv("ROOT_ROZO")
if ROZO_PATH != None:
  DIAG   = ROZO_PATH + "/tests/build/src/rozodiag/rozodiag"
else:
  DIAG   = which("rozodiag")


history = ""
persec=""
if options.history == True:
  #
  # History display 60 minutes and then 60 hours history in 
  # two loops. Global counters are displayed.  
  # 
  # 1rst loop will display per minute history
  history = " m"
  period = int(60)
  SIZE   = int(60) 
elif options.Phistory == True: 
  #
  # History display 60 minutes and then 60 hours history in 
  # two loops. Per second counters are displayed.
  # 
  # 1rst loop will display per minute history
  history = " m"
  period = int(60)
  SIZE   = int(60) 
  persec = "persec"
else:  
  #
  # Periodic mode has a default of 30 seconds period
  #
  period = int(30)  
  SIZE   = int(30)
  if options.period != None:
    try:
      period = int(options.period)
    except:
      syntax( "Bad period value %s"%(options.period))
    if period > int(30): period = int(30)
#
# Period can be either 60s for history
# or a divider of 30s for periodic mode
# 
if period > int(30): period = int(60)
else:
  if period > int(15): period = int(30)
  else:
    if period > int(10): period = int(15)
    else:
      if period > int(6): period = int(10)
      else:
          if period > int(5): period = int(6)
          else:
            if period > int(3): period = int(5)
            else:
              if period > int(2): period = int(3)
              else: period = int(2)  

#
# Filtering the colums to display
#  
what = ""    
if options.what != None:
  for w in options.what:
    for letter in w:
      what = what + ' ' + letter
#
# input RozoFS mount point is either in args or current path
#
if len(args) != 0: path = args[0]
else:              path = os.getcwd()

 
#
# Filetring rozofsmount upon IP addresses
#    
ipLowArray  = []
ipHighArray = []
ipRule      = []
NipLowArray  = []
NipHighArray = []
NipRule      = []

if options.iprange != None:
  for iprange in options.iprange:
    if len(iprange.split('-')) < 2:
      ipStringLow  = iprange
      ipStingHigh  = iprange
    else:      
      ipStringLow  = iprange.split('-')[0]
      ipStingHigh  = iprange.split('-')[1]
    try:
      ipLow  = get_ip(ipStringLow)
      ipHigh = get_ip(ipStingHigh)
    except:
      syntax( "Bad IP range %s"%(iprange))
    if ipLow > ipHigh:
      syntax( "Low IP is greater than high IP in range %s"%(iprange))
    ipLowArray.append(ipLow)
    ipHighArray.append(ipHigh)
    ipRule.append(iprange)

if options.Niprange != None:
  for iprange in options.Niprange:
    if len(iprange.split('-')) < 2:
      ipStringLow  = iprange
      ipStingHigh  = iprange
    else:
      ipStringLow  = iprange.split('-')[0]
      ipStingHigh  = iprange.split('-')[1]
    try:
      ipLow  = get_ip(ipStringLow)
      ipHigh = get_ip(ipStingHigh)
    except:
      syntax( "Bad IP range %s"%(iprange))
    if ipLow > ipHigh:
      syntax( "Low IP is greater than high IP in range %s"%(iprange))
    NipLowArray.append(ipLow)
    NipHighArray.append(ipHigh)      
    NipRule.append(iprange)
  
#
# A limit in time to run can be set
# 
max_run = int(2147483647)   
if options.delay != None:
  try :
    max_run = int(options.delay) * int(3600) / int(period)   
  except:
    syntax( "--delay must be an integer \"%s\""%(options.delay))  
nb_run = int(1)
        
# 
# Find the eid this path is connected to and then get the list of RozoFS
# clients on this eid from the export
#    
eid,exports,onlyClient = get_eid_and_exports_from_path(path)
clients = get_client_list(exports,eid)
if clients == "":
  syntax( "No client found")
  

print
print "  Clients of eid %s : "%(eid)
for client in clients.split("-i"):
  words = client.split()
  if len(words) >= 3:
    print "  - %s %s"%(words[0],words[2])
print  

#
# Change current directory 
# Not to block the file system
#
os.chdir("/")  

refresh_client_delay = int(0)

#
# Number of rozodiag round to display a full 
# array of result
#
round     = int(1)
if history != "":
  last_round = 1
else:  
  last_round = int(30)/int(period)

#
# Average arrays
#
average = []
average = [ int(0) for j in range(50) ]

#
# Record per column
#
record =  [ int(0) for j in range(50) ]    

#
# Max value per column
#
if options.bold == True: max_col_val = [ int(0) for j in range(50) ]  

start = True          
while True : 

  #
  # Every 3 minutes refresh client list
  #
  refresh_client_delay = refresh_client_delay + period
  if refresh_client_delay > int(180) : 
    clients =  get_client_list(exports,eid)
    refresh_client_delay = int(0)

  #
  # Get current time
  #
  now    = datetime.datetime.now()
  zedate = now.strftime("%Y/%m/%d %H:%M:%S")
  minute = int(now.strftime("%M"))
  sec    = int(now.strftime("%S"))
  #
  # Run the rozodiag command against all clients
  #
  string="%s %s -c io col 1 %s %s"%(DIAG,clients,what,persec)
  string += history  
  parsed = shlex.split(string)
  cmd = subprocess.Popen(parsed, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

  time_col_val = []
  time_col_val = [[ int(0) for j in range(50) ] for i in range(60) ]             

  if round == int(1):
    if options.bold == True: max_col_val = [ int(0) for j in range(50) ]  
    
  #
  # Parse output and cumulate the throughputs
  #
  for line in cmd.stdout:
  
    if not "|" in line : continue
 
    words = line.split("|")
    nbColumn = len(words) - int(3)
    
    if start == True:
      titles = words[2:]
      try:
        if total_column != nbColumn: 
          total_column = nbColumn
      except:         
        total_column = nbColumn
      build_upline(titles,total_column)        
      start = False
      continue
    
    if nbColumn > total_column: nbColumn = total_column
      
    #
    # Get time value
    #
    try:
      deltaTime =  -int(words[1]) -1
      if deltaTime >= period: continue
    except:
      continue

    for column in range(nbColumn):

      val = common_convert_Bytes( words[column+2])
      if int(val) == int(0): continue
      
      # Case of the latency expressed in us
      # One can not sum up the latencies but must make an average
      if " us" in titles[column]:
        # Multiply latency with number of I/O to get a duration
        val = val * common_convert_Bytes( words[column+1])              

      try:
      
        new_val = time_col_val[deltaTime][column] + int(val)
        time_col_val[deltaTime][column] = new_val                 
        #
        # For average option add the value on the average
        #              
        average[column] += int(val) 
             
      except:

        syntax( "Error on t %s column %s val %s"%(deltaTime,column,val) ) 

  # Rework values before display
  for column in range(nbColumn):  

    for t in range(SIZE):
    
      new_val = time_col_val[t][column]
      if new_val == int(0): continue
      
      # Case of the latency expressed in us. We have computed a duration
      # Divide duration by number of I/O to get a latency      
      if " us" in titles[column]:   
        if  time_col_val[t][column-1] != int(0):   
          new_val = new_val / time_col_val[t][column-1] 
          time_col_val[t][column] = new_val
                
      # Check for maximum value  
      if options.bold == True:
        if max_col_val[column] < new_val: max_col_val[column] = new_val
        if record[column] < new_val:  record[column] = new_val   

  #
  # Round 1 : display header and records
  #
  if int(round) == int(1) : 
    LINE = zedate + " - %d/%d  RozoFS clients on "%(total_watched_clients,total_nb_clients)  + GREEN + "eid " + eid  + NORMAL
    
    if history != "":
      LINE += " - Last " + REVERSE + "60 "
      if history == " m":   LINE += "minutes" 
      elif history == " h": LINE += "hours"
      LINE += NORMAL + " history " + REVERSE
      if persec != "": 
        LINE += "(per second counters)"  
      else:
        LINE += "(cumulated counters)"  
      LINE += NORMAL          
                    
    print LINE
       
    LINE = "     "
    for column in range(nbColumn):
      color = get_color_code(column)
      LINE = LINE + ' ' + color + "%7s "%(common_bytes_with_unit(record[column])) + NORMAL
    print LINE        
    print UP_LINE 

  #
  # Display some raws
  #    
  for raw in range(SIZE):
    if raw < int(SIZE)-period: continue
    deltaTime = SIZE - 1 - raw
      
    if history == "": 
      m,s = delta_time(minute,sec, 1 + deltaTime)
      LINE = "%2.2d:%2.2d"%(m,s)
    else:
      LINE = " -%2.2d "%(1+deltaTime)  
    
    for column in range(nbColumn):
      color = get_color_code(column)
      if options.bold:
        if max_col_val[column] != int(0):
          if time_col_val[deltaTime][column] == max_col_val[column]: color = color + REVERSE
      LINE = LINE + '|' + color + "%7s "%(common_bytes_with_unit(time_col_val[deltaTime][column])) + NORMAL
    LINE = LINE + "|" 
    print LINE  

  if int(round) != int(last_round):
    round = int(round) + int(1)
  else:
    #
    # Last round : Display BOTTOM_LINE and averages
    #    
    round = int(1)
    print BOTTOM_LINE      
    LINE ="     "
    for column in range(nbColumn):
      color = get_color_code(column)
      # Case of the latency expressed in us. We have computed a duration
      # Divide duration by number of I/O to get a latency      
      if " us" in titles[column]:   
        if average[column-1] != int(0):
          LINE = LINE + '|' + color + "%7s "%(common_bytes_with_unit(average[column]/average[column-1])) + NORMAL
        else:
          LINE = LINE + '|' + color + "%7s "%(common_bytes_with_unit(0)) + NORMAL            
      else:
        LINE = LINE + '|' + color + "%7s "%(common_bytes_with_unit(average[column]/SIZE)) + NORMAL
    LINE = LINE + "|     " 
    average = [ int(0) for j in range(50) ]
    print LINE
    

  sys.stdout.flush()

    
  #
  # Go out after history per hour displey
  #  
  if history == " h": break
  
  #
  # Reloop after history per minute, in order to
  # now display history per hour
  #
  if history == " m": 
    history = " h"
    record =  [ int(0) for j in range(50) ]    
    continue  
    
  #
  # Not periodic so go out
  #
  if period == 0: break
    
  #
  # Periodic, but with a limited count
  #  
  if options.verbose == True: print "Run %s/%s"%(nb_run,max_run)
  if options.delay != None:
    if int(nb_run) >= int(max_run): 
      record =  [ int(0) for j in range(50) ]    
      history = " m"
      last_round = int(1)
      period = int(60)
      SIZE   = int(60)       
      start = True
      continue
    nb_run = nb_run + int(1)
  #
  # Sleep before reloop
  #  
  time.sleep(period)
    
