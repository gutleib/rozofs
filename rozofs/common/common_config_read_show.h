/*

 File generated by ../../tools/common_config.py from common_config.input

 Copyright (c) 2010 Fizians SAS. <http://www.fizians.com>
 This file is part of Rozofs.

 Rozofs is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published
 by the Free Software Foundation, version 2.

 Rozofs is distributed in the hope that it will be useful, but
 WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see
 <http://www.gnu.org/licenses/>.
 */
#ifndef _COMMON_CONFIG_READ_SHOW_H
#define _COMMON_CONFIG_READ_SHOW_H

#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <errno.h>
#include <libconfig.h>
#include <unistd.h>
#include <inttypes.h>
#include <sys/types.h>
#include <dirent.h>
/*____________________________________________________________________________________________
**
** Set a value to a common configuration parameter
** 
** @param param   Parameter name
** @param value   New value to set
** 
** @retval 1 on success, 0 else
*/
static inline int common_config_generated_set(char * pChar, char *parameter, char *value) {
  if (strcmp(parameter,"nb_core_file")==0) {
    COMMON_CONFIG_SET_INT_MINMAX(nb_core_file,value,0,8);
  }
  if (strcmp(parameter,"core_file_directory")==0) {
    COMMON_CONFIG_SET_STRING(core_file_directory,value);
  }
  if (strcmp(parameter,"numa_aware")==0) {
    COMMON_CONFIG_SET_BOOL(numa_aware,value);
  }
  if (strcmp(parameter,"adaptor_numa_node")==0) {
    COMMON_CONFIG_SET_INT(adaptor_numa_node,value);
  }
  if (strcmp(parameter,"processor_model")==0) {
    COMMON_CONFIG_PROCESSOR_MODEL_SET_ENUM(value);
  }
  if (strcmp(parameter,"storio_slice_number")==0) {
    COMMON_CONFIG_SET_INT_MINMAX(storio_slice_number,value,8,(32*1024));
  }
  if (strcmp(parameter,"file_distribution_rule")==0) {
    COMMON_CONFIG_SET_INT_MINMAX(file_distribution_rule,value,0,100);
  }
  if (strcmp(parameter,"storio_dscp")==0) {
    COMMON_CONFIG_SET_INT_MINMAX(storio_dscp,value,0,46);
  }
  if (strcmp(parameter,"export_dscp")==0) {
    COMMON_CONFIG_SET_INT_MINMAX(export_dscp,value,0,34);
  }
  if (strcmp(parameter,"trashed_file_per_run")==0) {
    COMMON_CONFIG_SET_INT(trashed_file_per_run,value);
  }
  if (strcmp(parameter,"trash_high_threshold")==0) {
    COMMON_CONFIG_SET_INT_MINMAX(trash_high_threshold,value,0,1000000);
  }
  if (strcmp(parameter,"fid_recycle")==0) {
    COMMON_CONFIG_SET_BOOL(fid_recycle,value);
  }
  if (strcmp(parameter,"wr_ack_on_inverse")==0) {
    COMMON_CONFIG_SET_BOOL(wr_ack_on_inverse,value);
  }
  if (strcmp(parameter,"wr_pending_anticipated")==0) {
    COMMON_CONFIG_SET_BOOL(wr_pending_anticipated,value);
  }
  if (strcmp(parameter,"export_buf_cnt")==0) {
    COMMON_CONFIG_SET_INT_MINMAX(export_buf_cnt,value,32,1024);
  }
  if (strcmp(parameter,"nb_storaged_subthread")==0) {
    COMMON_CONFIG_SET_INT_MINMAX(nb_storaged_subthread,value,2,16);
  }
  if (strcmp(parameter,"nb_disk_thread")==0) {
    COMMON_CONFIG_SET_INT_MINMAX(nb_disk_thread,value,2,64);
  }
  if (strcmp(parameter,"nb_write_rdma_threads")==0) {
    COMMON_CONFIG_SET_INT_MINMAX(nb_write_rdma_threads,value,2,64);
  }
  if (strcmp(parameter,"rdma_write_thread_enable")==0) {
    COMMON_CONFIG_SET_BOOL(rdma_write_thread_enable,value);
  }
  if (strcmp(parameter,"crc32c_check")==0) {
    COMMON_CONFIG_SET_BOOL(crc32c_check,value);
  }
  if (strcmp(parameter,"crc32c_generate")==0) {
    COMMON_CONFIG_SET_BOOL(crc32c_generate,value);
  }
  if (strcmp(parameter,"crc32c_hw_forced")==0) {
    COMMON_CONFIG_SET_BOOL(crc32c_hw_forced,value);
  }
  if (strcmp(parameter,"allow_disk_spin_down")==0) {
    COMMON_CONFIG_SET_BOOL(allow_disk_spin_down,value);
  }
  if (strcmp(parameter,"disk_usage_threshold")==0) {
    COMMON_CONFIG_SET_INT_MINMAX(disk_usage_threshold,value,0,100);
  }
  if (strcmp(parameter,"disk_read_threshold")==0) {
    COMMON_CONFIG_SET_INT(disk_read_threshold,value);
  }
  if (strcmp(parameter,"disk_write_threshold")==0) {
    COMMON_CONFIG_SET_INT(disk_write_threshold,value);
  }
  if (strcmp(parameter,"storio_buf_cnt")==0) {
    COMMON_CONFIG_SET_INT_MINMAX(storio_buf_cnt,value,32,1024);
  }
  if (strcmp(parameter,"recycle_truncate_blocks")==0) {
    COMMON_CONFIG_SET_INT(recycle_truncate_blocks,value);
  }
  if (strcmp(parameter,"export_attr_thread")==0) {
    COMMON_CONFIG_SET_BOOL(export_attr_thread,value);
  }
  if (strcmp(parameter,"rozofsmount_fuse_reply_thread")==0) {
    COMMON_CONFIG_SET_INT_MINMAX(rozofsmount_fuse_reply_thread,value,0,4);
  }
  if (strcmp(parameter,"export_versioning")==0) {
    COMMON_CONFIG_SET_BOOL(export_versioning,value);
  }
  if (strcmp(parameter,"alloc_estimated_mb")==0) {
    COMMON_CONFIG_SET_INT(alloc_estimated_mb,value);
  }
  if (strcmp(parameter,"storaged_start_script")==0) {
    COMMON_CONFIG_SET_STRING(storaged_start_script,value);
  }
  if (strcmp(parameter,"client_flock_timeout")==0) {
    COMMON_CONFIG_SET_INT_MINMAX(client_flock_timeout,value,15,600);
  }
  if (strcmp(parameter,"device_automount")==0) {
    COMMON_CONFIG_SET_BOOL(device_automount,value);
  }
  if (strcmp(parameter,"device_automount_path")==0) {
    COMMON_CONFIG_SET_STRING(device_automount_path,value);
  }
  if (strcmp(parameter,"device_automount_option")==0) {
    COMMON_CONFIG_SET_STRING(device_automount_option,value);
  }
  if (strcmp(parameter,"mproto_timeout")==0) {
    COMMON_CONFIG_SET_INT_MINMAX(mproto_timeout,value,1,60);
  }
  if (strcmp(parameter,"export_temporary_dir")==0) {
    COMMON_CONFIG_SET_STRING(export_temporary_dir,value);
  }
  if (strcmp(parameter,"storage_temporary_dir")==0) {
    COMMON_CONFIG_SET_STRING(storage_temporary_dir,value);
  }
  if (strcmp(parameter,"mkdir_ok_instead_of_eexist")==0) {
    COMMON_CONFIG_SET_BOOL(mkdir_ok_instead_of_eexist,value);
  }
  if (strcmp(parameter,"mknod_ok_instead_of_eexist")==0) {
    COMMON_CONFIG_SET_BOOL(mknod_ok_instead_of_eexist,value);
  }
  if (strcmp(parameter,"client_fast_reconnect")==0) {
    COMMON_CONFIG_SET_BOOL(client_fast_reconnect,value);
  }
  if (strcmp(parameter,"archive_file_delay")==0) {
    COMMON_CONFIG_SET_INT_MINMAX(archive_file_delay,value,0,3600);
  }
  if (strcmp(parameter,"archive_file_dentry_timeout")==0) {
    COMMON_CONFIG_SET_INT_MINMAX(archive_file_dentry_timeout,value,0,300);
  }
  if (strcmp(parameter,"archive_file_attr_timeout")==0) {
    COMMON_CONFIG_SET_INT_MINMAX(archive_file_attr_timeout,value,0,300);
  }
  if (strcmp(parameter,"disable_sync_attributes")==0) {
    COMMON_CONFIG_SET_BOOL(disable_sync_attributes,value);
  }
  if (strcmp(parameter,"device_self_healing_process")==0) {
    COMMON_CONFIG_SET_INT_MINMAX(device_self_healing_process,value,1,64);
  }
  if (strcmp(parameter,"device_selfhealing_delay")==0) {
    COMMON_CONFIG_SET_INT_MINMAX(device_selfhealing_delay,value,0,10000);
  }
  if (strcmp(parameter,"device_selfhealing_read_throughput")==0) {
    COMMON_CONFIG_SET_INT_MINMAX(device_selfhealing_read_throughput,value,0,10000);
  }
  if (strcmp(parameter,"device_selfhealing_mode")==0) {
    COMMON_CONFIG_DEVICE_SELFHEALING_MODE_SET_ENUM(value);
  }
  if (strcmp(parameter,"export_hosts")==0) {
    COMMON_CONFIG_SET_STRING(export_hosts,value);
  }
  if (strcmp(parameter,"deletion_delay")==0) {
    COMMON_CONFIG_SET_INT(deletion_delay,value);
  }
  if (strcmp(parameter,"spare_restore_enable")==0) {
    COMMON_CONFIG_SET_BOOL(spare_restore_enable,value);
  }
  if (strcmp(parameter,"spare_restore_loop_delay")==0) {
    COMMON_CONFIG_SET_INT(spare_restore_loop_delay,value);
  }
  if (strcmp(parameter,"default_rebuild_reloop")==0) {
    COMMON_CONFIG_SET_INT(default_rebuild_reloop,value);
  }
  if (strcmp(parameter,"spare_restore_read_throughput")==0) {
    COMMON_CONFIG_SET_INT(spare_restore_read_throughput,value);
  }
  if (strcmp(parameter,"storio_fidctx_ctx")==0) {
    COMMON_CONFIG_SET_INT(storio_fidctx_ctx,value);
  }
  if (strcmp(parameter,"client_xattr_cache")==0) {
    COMMON_CONFIG_SET_BOOL(client_xattr_cache,value);
  }
  if (strcmp(parameter,"async_setattr")==0) {
    COMMON_CONFIG_SET_BOOL(async_setattr,value);
  }
  if (strcmp(parameter,"statfs_period")==0) {
    COMMON_CONFIG_SET_INT(statfs_period,value);
  }
  if (strcmp(parameter,"spare_restore_spare_ctx")==0) {
    COMMON_CONFIG_SET_INT(spare_restore_spare_ctx,value);
  }
  if (strcmp(parameter,"min_metadata_inodes")==0) {
    COMMON_CONFIG_SET_INT(min_metadata_inodes,value);
  }
  if (strcmp(parameter,"min_metadata_MB")==0) {
    COMMON_CONFIG_SET_INT(min_metadata_MB,value);
  }
  if (strcmp(parameter,"nb_trash_thread")==0) {
    COMMON_CONFIG_SET_INT_MINMAX(nb_trash_thread,value,1,8);
  }
  if (strcmp(parameter,"nb_thin_thread")==0) {
    COMMON_CONFIG_SET_INT_MINMAX(nb_thin_thread,value,1,4);
  }
  if (strcmp(parameter,"thin_scan_file_per_run")==0) {
    COMMON_CONFIG_SET_INT(thin_scan_file_per_run,value);
  }
  if (strcmp(parameter,"thin_lv1_hash_tb_size")==0) {
    COMMON_CONFIG_SET_INT_MINMAX(thin_lv1_hash_tb_size,value,6,128);
  }
  if (strcmp(parameter,"expthin_guard_delay_sec")==0) {
    COMMON_CONFIG_SET_INT_MINMAX(expthin_guard_delay_sec,value,1,600);
  }
  if (strcmp(parameter,"rdma_enable")==0) {
    COMMON_CONFIG_SET_BOOL(rdma_enable,value);
  }
  if (strcmp(parameter,"rdma_full")==0) {
    COMMON_CONFIG_SET_BOOL(rdma_full,value);
  }
  if (strcmp(parameter,"min_rmda_size_KB")==0) {
    COMMON_CONFIG_SET_INT(min_rmda_size_KB,value);
  }
  if (strcmp(parameter,"rdma_delay_ms")==0) {
    COMMON_CONFIG_SET_INT(rdma_delay_ms,value);
  }
  if (strcmp(parameter,"rdma_delay_threshold")==0) {
    COMMON_CONFIG_SET_INT_MINMAX(rdma_delay_threshold,value,0,64);
  }
  if (strcmp(parameter,"mojette_thread_count")==0) {
    COMMON_CONFIG_SET_INT_MINMAX(mojette_thread_count,value,1,4);
  }
  if (strcmp(parameter,"reply_thread_count")==0) {
    COMMON_CONFIG_SET_INT_MINMAX(reply_thread_count,value,1,8);
  }
  if (strcmp(parameter,"bufread_bypass")==0) {
    COMMON_CONFIG_SET_BOOL(bufread_bypass,value);
  }
  if (strcmp(parameter,"expdir_guard_delay_sec")==0) {
    COMMON_CONFIG_SET_INT_MINMAX(expdir_guard_delay_sec,value,1,7200);
  }
  if (strcmp(parameter,"level2_cache_max_entries_kb")==0) {
    COMMON_CONFIG_SET_INT_MINMAX(level2_cache_max_entries_kb,value,1,4096);
  }
  if (strcmp(parameter,"standalone")==0) {
    COMMON_CONFIG_SET_BOOL(standalone,value);
  }
  if (strcmp(parameter,"persistent_file_locks")==0) {
    COMMON_CONFIG_SET_BOOL(persistent_file_locks,value);
  }
  if (strcmp(parameter,"minimum_free_size_percent")==0) {
    COMMON_CONFIG_SET_INT_MINMAX(minimum_free_size_percent,value,0,100);
  }
  if (strcmp(parameter,"mandatory_device_label")==0) {
    COMMON_CONFIG_SET_BOOL(mandatory_device_label,value);
  }
  if (strcmp(parameter,"storcli_read_parallel")==0) {
    COMMON_CONFIG_SET_BOOL(storcli_read_parallel,value);
  }
  if (strcmp(parameter,"diagnostic_mode")==0) {
    COMMON_CONFIG_DIAGNOSTIC_MODE_SET_ENUM(value);
  }
  if (strcmp(parameter,"expbt_active")==0) {
    COMMON_CONFIG_SET_BOOL(expbt_active,value);
  }
  if (strcmp(parameter,"nb_expbt_thread")==0) {
    COMMON_CONFIG_SET_INT_MINMAX(nb_expbt_thread,value,2,32);
  }
  if (strcmp(parameter,"expbt_buf_cnt")==0) {
    COMMON_CONFIG_SET_INT_MINMAX(expbt_buf_cnt,value,8,128);
  }
  if (strcmp(parameter,"dirent_cache_size")==0) {
    COMMON_CONFIG_SET_INT_MINMAX(dirent_cache_size,value,2,500000);
  }
  if (strcmp(parameter,"dirent_garbage_delay")==0) {
    COMMON_CONFIG_SET_INT_MINMAX(dirent_garbage_delay,value,1,60);
  }
  if (strcmp(parameter,"trk_cache_size")==0) {
    COMMON_CONFIG_SET_INT_MINMAX(trk_cache_size,value,32,8192);
  }
  if (strcmp(parameter,"trk_garbage_delay")==0) {
    COMMON_CONFIG_SET_INT_MINMAX(trk_garbage_delay,value,1,60);
  }
  if (strcmp(parameter,"trk_expiration_delay")==0) {
    COMMON_CONFIG_SET_INT_MINMAX(trk_expiration_delay,value,4,600);
  }
  pChar += rozofs_string_append_error(pChar,"No such parameter ");
  pChar += rozofs_string_append_error(pChar,parameter);
  pChar += rozofs_eol(pChar);\
  return -1;
}
/*____________________________________________________________________________________________
**
** Search for parameters approximatively like a given string 
** 
** @param parameter   Approximative parameter name we are searching for
** 
** @retval The number of parameters matching the input string
*/
static inline int common_config_generated_search(char * pChar, char *parameter) {
  int match = 0;

  if (strcasestr("nb_core_file",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(nb_core_file,1);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// Number of core files that the system is allowed to keep for all the modules of this server.\n");
    pChar += rozofs_string_append(pChar,"// Older core files are kept while newest are removed.	\n");
    COMMON_CONFIG_SHOW_INT_OPT(nb_core_file,1,"0:8");
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("core_file_directory",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_STRING(core_file_directory,"");
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// Directory where the core files are stored.\n");
    COMMON_CONFIG_SHOW_STRING(core_file_directory,"");
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("numa_aware",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_BOOL(numa_aware,False);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// Enables to take into account the NUMA architecture of the board in \n");
    pChar += rozofs_string_append(pChar,"// order to collocate some RozoFS modules on the same node for memory\n");
    pChar += rozofs_string_append(pChar,"// access efficiency.\n");
    COMMON_CONFIG_SHOW_BOOL(numa_aware,False);
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("adaptor_numa_node",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(adaptor_numa_node,-1);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// Ethernet Adaptor numa node (-1 not significant)\n");
    COMMON_CONFIG_SHOW_INT(adaptor_numa_node,-1);
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("processor_model",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_ENUM(processor_model,"INTEL");
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// processor model:\n");
    pChar += rozofs_string_append(pChar,"// EPYC: all AMD CPUs \n");
    pChar += rozofs_string_append(pChar,"// INTEL:   covers E5 & skylake families\n");
    COMMON_CONFIG_SHOW_ENUM(processor_model,""INTEL"","EPYC,INTEL");
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("storio_slice_number",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(storio_slice_number,1024);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// Number of slices in the STORIO.\n");
    COMMON_CONFIG_SHOW_INT_OPT(storio_slice_number,1024,"8:(32*1024)");
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("file_distribution_rule",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(file_distribution_rule,0);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// File distribution mode upon cluster, storages and devices. Check rozofs.conf manual.\n");
    pChar += rozofs_string_append(pChar,"// 0         = Cluster size balancing                   + device size balancing\n");
    pChar += rozofs_string_append(pChar,"// 1,2,3     = Cluster strict round robin               + device write spreading\n");
    pChar += rozofs_string_append(pChar,"// 4         = Cluster strict round robin               + device read spreading\n");
    pChar += rozofs_string_append(pChar,"// 5         = Cluster weighted round robin (nb SID)    + device write spreading\n");
    pChar += rozofs_string_append(pChar,"// 6         = Cluster weighted round robin (nb SID)    + device read spreading\n");
    pChar += rozofs_string_append(pChar,"// 7         = Cluster weighted round robin (free size) + device write spreading\n");
    pChar += rozofs_string_append(pChar,"// 6         = Cluster weighted round robin (free size) + device read spreading\n");
    COMMON_CONFIG_SHOW_INT_OPT(file_distribution_rule,0,"0:100");
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("storio_dscp",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(storio_dscp,46);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// DSCP for exchanges from/to the STORIO.\n");
    COMMON_CONFIG_SHOW_INT_OPT(storio_dscp,46,"0:46");
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("export_dscp",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(export_dscp,34);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// DSCP for exchanges from/to the EXPORTD.\n");
    COMMON_CONFIG_SHOW_INT_OPT(export_dscp,34,"0:34");
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("trashed_file_per_run",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(trashed_file_per_run,1000);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// Max number of file that the exportd can remove from storages in a run.\n");
    pChar += rozofs_string_append(pChar,"// A new run occurs every 2 seconds.\n");
    COMMON_CONFIG_SHOW_INT(trashed_file_per_run,1000);
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("trash_high_threshold",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(trash_high_threshold,1000);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// High trash water mark when FID recycling is activated.\n");
    pChar += rozofs_string_append(pChar,"// When the trash has already this number of files, files are no more\n");
    pChar += rozofs_string_append(pChar,"// deleted but recycled.\n");
    COMMON_CONFIG_SHOW_INT_OPT(trash_high_threshold,1000,"0:1000000");
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("fid_recycle",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_BOOL(fid_recycle,False);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// Whether FID recycling feature is activated.\n");
    COMMON_CONFIG_SHOW_BOOL(fid_recycle,False);
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("wr_ack_on_inverse",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_BOOL(wr_ack_on_inverse,False);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// Whether STORCLI acknowleges write request on inverse or forward STORIO responses.\n");
    COMMON_CONFIG_SHOW_BOOL(wr_ack_on_inverse,False);
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("wr_pending_anticipated",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_BOOL(wr_pending_anticipated,False);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// To indicate if we can respond before write_pending reaches 0.\n");
    COMMON_CONFIG_SHOW_BOOL(wr_pending_anticipated,False);
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("export_buf_cnt",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(export_buf_cnt,128);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    COMMON_CONFIG_SHOW_INT_OPT(export_buf_cnt,128,"32:1024");
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("nb_storaged_subthread",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(nb_storaged_subthread,8);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// Number of sub threads in the storaged\n");
    COMMON_CONFIG_SHOW_INT_OPT(nb_storaged_subthread,8,"2:16");
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("nb_disk_thread",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(nb_disk_thread,4);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"/// Number of disk threads in the STORIO.\n");
    COMMON_CONFIG_SHOW_INT_OPT(nb_disk_thread,4,"2:64");
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("nb_write_rdma_threads",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(nb_write_rdma_threads,4);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"/// Number of RDMA write threads in the STORIO.\n");
    COMMON_CONFIG_SHOW_INT_OPT(nb_write_rdma_threads,4,"2:64");
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("rdma_write_thread_enable",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_BOOL(rdma_write_thread_enable,False);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// assert that Boolean to activate the RDMA write threads.\n");
    COMMON_CONFIG_SHOW_BOOL(rdma_write_thread_enable,False);
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("crc32c_check",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_BOOL(crc32c_check,True);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// Whether CRC32 MUST be checked by STORIO.\n");
    COMMON_CONFIG_SHOW_BOOL(crc32c_check,True);
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("crc32c_generate",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_BOOL(crc32c_generate,True);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// Whether CRC32 MUST be computed by STORIO.\n");
    COMMON_CONFIG_SHOW_BOOL(crc32c_generate,True);
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("crc32c_hw_forced",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_BOOL(crc32c_hw_forced,False);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// Whether CRC32 MUST be absolutly hardware computed by STORIO.\n");
    COMMON_CONFIG_SHOW_BOOL(crc32c_hw_forced,False);
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("allow_disk_spin_down",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_BOOL(allow_disk_spin_down,False);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// Whether STORIO device monitoring should avoid reading from \n");
    pChar += rozofs_string_append(pChar,"// devices when no access have occured for read or write. This\n");
    pChar += rozofs_string_append(pChar,"// enables disk spin down to occur.\n");
    COMMON_CONFIG_SHOW_BOOL(allow_disk_spin_down,False);
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("disk_usage_threshold",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(disk_usage_threshold,0);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// Over which device usage threashold should the STORIO log the event. \n");
    COMMON_CONFIG_SHOW_INT_OPT(disk_usage_threshold,0,"0:100");
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("disk_read_threshold",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(disk_read_threshold,0);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// Over which device read delay threashold should the STORIO log the event. \n");
    COMMON_CONFIG_SHOW_INT(disk_read_threshold,0);
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("disk_write_threshold",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(disk_write_threshold,0);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// Over which device write delay threashold should the STORIO log the event. \n");
    COMMON_CONFIG_SHOW_INT(disk_write_threshold,0);
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("storio_buf_cnt",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(storio_buf_cnt,256);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// Number of STORIO receive buffer.\n");
    COMMON_CONFIG_SHOW_INT_OPT(storio_buf_cnt,256,"32:1024");
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("recycle_truncate_blocks",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(recycle_truncate_blocks,0);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// Number of block to which the chunk files should be truncated on storage \n");
    pChar += rozofs_string_append(pChar,"// node at the time it is recycled.\n");
    COMMON_CONFIG_SHOW_INT(recycle_truncate_blocks,0);
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("export_attr_thread",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_BOOL(export_attr_thread,True);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// To activate export writebehind attributes thread.\n");
    COMMON_CONFIG_SHOW_BOOL(export_attr_thread,True);
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("rozofsmount_fuse_reply_thread",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(rozofsmount_fuse_reply_thread,0);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// To activate rozofsmount reply fuse threads.\n");
    COMMON_CONFIG_SHOW_INT_OPT(rozofsmount_fuse_reply_thread,0,"0:4");
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("export_versioning",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_BOOL(export_versioning,False);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// Support of deleted directory/file versioning.\n");
    COMMON_CONFIG_SHOW_BOOL(export_versioning,False);
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("alloc_estimated_mb",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(alloc_estimated_mb,1);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// Number of MB to account a file for during file distribution phase\n");
    COMMON_CONFIG_SHOW_INT(alloc_estimated_mb,1);
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("storaged_start_script",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_STRING(storaged_start_script,"");
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// Name of an executable file that the storaged should call at startup\n");
    COMMON_CONFIG_SHOW_STRING(storaged_start_script,"");
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("client_flock_timeout",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(client_flock_timeout,30);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// Delay from which a rozofsmoun client is declared disconnected and its \n");
    pChar += rozofs_string_append(pChar,"// file locks are automatically removed\n");
    COMMON_CONFIG_SHOW_INT_OPT(client_flock_timeout,30,"15:600");
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("device_automount",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_BOOL(device_automount,False);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// Whether the storage has to automount the devices\n");
    COMMON_CONFIG_SHOW_BOOL(device_automount,False);
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("device_automount_path",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_STRING(device_automount_path,"/srv/rozofs/storages");
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// automount path where the devices should be mounted\n");
    COMMON_CONFIG_SHOW_STRING(device_automount_path,"/srv/rozofs/storages");
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("device_automount_option",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_STRING(device_automount_option,"");
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// Device mounting options\n");
    COMMON_CONFIG_SHOW_STRING(device_automount_option,"");
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("mproto_timeout",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(mproto_timeout,10);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// Time out between export and storage for remove and stat\n");
    COMMON_CONFIG_SHOW_INT_OPT(mproto_timeout,10,"1:60");
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("export_temporary_dir",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_STRING(export_temporary_dir,"/tmp");
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// Directory to use on the export to build temporary files.\n");
    pChar += rozofs_string_append(pChar,"// Used for instance to build list of files to rebuild.\n");
    COMMON_CONFIG_SHOW_STRING(export_temporary_dir,"/tmp");
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("storage_temporary_dir",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_STRING(storage_temporary_dir,"/tmp");
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// Directory to use on the storage node to build temporary files.\n");
    pChar += rozofs_string_append(pChar,"// Used for instance by the rebuild process.\n");
    COMMON_CONFIG_SHOW_STRING(storage_temporary_dir,"/tmp");
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("mkdir_ok_instead_of_eexist",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_BOOL(mkdir_ok_instead_of_eexist,False);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// To activate workaround that make mkdir respond OK instead of EEXIST\n");
    pChar += rozofs_string_append(pChar,"// when the directory is already created \n");
    COMMON_CONFIG_SHOW_BOOL(mkdir_ok_instead_of_eexist,False);
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("mknod_ok_instead_of_eexist",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_BOOL(mknod_ok_instead_of_eexist,False);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// To activate workaround that make mknod respond OK instead of EEXIST\n");
    pChar += rozofs_string_append(pChar,"// when the file is already created  \n");
    COMMON_CONFIG_SHOW_BOOL(mknod_ok_instead_of_eexist,False);
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("client_fast_reconnect",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_BOOL(client_fast_reconnect,False);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// To activate fast reconnect from client to exportd\n");
    COMMON_CONFIG_SHOW_BOOL(client_fast_reconnect,False);
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("archive_file_delay",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(archive_file_delay,10);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// delay is minutes after which a file is considered as an archived file (unit is minute)\n");
    COMMON_CONFIG_SHOW_INT_OPT(archive_file_delay,10,"0:3600");
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("archive_file_dentry_timeout",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(archive_file_dentry_timeout,30);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// dentry cache timeout for archive file type (unit is second)\n");
    COMMON_CONFIG_SHOW_INT_OPT(archive_file_dentry_timeout,30,"0:300");
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("archive_file_attr_timeout",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(archive_file_attr_timeout,30);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// attribute cache timeout for archive file type (unit is second)\n");
    COMMON_CONFIG_SHOW_INT_OPT(archive_file_attr_timeout,30,"0:300");
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("disable_sync_attributes",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_BOOL(disable_sync_attributes,False);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// To disable synchronous write of attributes when set to True\n");
    COMMON_CONFIG_SHOW_BOOL(disable_sync_attributes,False);
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("device_self_healing_process",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(device_self_healing_process,8);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// self healing : Paralellism factor for device self healing feature\n");
    pChar += rozofs_string_append(pChar,"// i.e the number of process to run rebuild in //\n");
    COMMON_CONFIG_SHOW_INT_OPT(device_self_healing_process,8,"1:64");
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("device_selfhealing_delay",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(device_selfhealing_delay,15);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// self healing : Fault duration in minutes before device selfhealing starts\n");
    COMMON_CONFIG_SHOW_INT_OPT(device_selfhealing_delay,15,"0:10000");
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("device_selfhealing_read_throughput",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(device_selfhealing_read_throughput,40);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// self healing :  throughput limitation in MB/s per rebuild process in //\n");
    pChar += rozofs_string_append(pChar,"// for reading external projections. The writing on disk is only\n");
    pChar += rozofs_string_append(pChar,"// 1/2 of that in layout 0, 1/4 in layout 1...\n");
    pChar += rozofs_string_append(pChar,"// 0 means no limit\n");
    COMMON_CONFIG_SHOW_INT_OPT(device_selfhealing_read_throughput,40,"0:10000");
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("device_selfhealing_mode",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_ENUM(device_selfhealing_mode,"spareOnly");
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// self healing : possible modes\n");
    pChar += rozofs_string_append(pChar,"// spareOnly  only self repair on a spare disk\n");
    pChar += rozofs_string_append(pChar,"// relocate   also repair on remaining disks when no spare available\n");
    pChar += rozofs_string_append(pChar,"// resecure   repair on spare device when available, and then resecure files on\n");
    pChar += rozofs_string_append(pChar,"//            spare storages when no spare device is available\n");
    pChar += rozofs_string_append(pChar,"// none       No self healing is processed. Only manual rebuild is allowed.\n");
    COMMON_CONFIG_SHOW_ENUM(device_selfhealing_mode,""spareOnly"","spareOnly,resecure,relocate,none");
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("export_hosts",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_STRING(export_hosts,"");
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// Export host names or IP addresses separated with / \n");
    pChar += rozofs_string_append(pChar,"// Required for selfhealing.\n");
    pChar += rozofs_string_append(pChar,"// Required for spare file restoring to its nominal location.\n");
    COMMON_CONFIG_SHOW_STRING(export_hosts,"");
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("deletion_delay",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(deletion_delay,30);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// Minimum delay between the deletion request and the effective projections deletion\n");
    COMMON_CONFIG_SHOW_INT(deletion_delay,30);
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("spare_restore_enable",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_BOOL(spare_restore_enable,True);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// Spare file restoring : whether the service is active or not\n");
    COMMON_CONFIG_SHOW_BOOL(spare_restore_enable,True);
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("spare_restore_loop_delay",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(spare_restore_loop_delay,240);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// Spare file restoring : how often the process runs  \n");
    COMMON_CONFIG_SHOW_INT(spare_restore_loop_delay,240);
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("default_rebuild_reloop",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(default_rebuild_reloop,4);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// Default rebuild reloop value \n");
    pChar += rozofs_string_append(pChar,"// Mainly used to help simulation\n");
    COMMON_CONFIG_SHOW_INT(default_rebuild_reloop,4);
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("spare_restore_read_throughput",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(spare_restore_read_throughput,10);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// Spare file restoring : throughput limitation for reading and analyzing spare files in MB/s\n");
    pChar += rozofs_string_append(pChar,"// 0 means no limit\n");
    COMMON_CONFIG_SHOW_INT(spare_restore_read_throughput,10);
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("storio_fidctx_ctx",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(storio_fidctx_ctx,256);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// Storio number of FID context in 1K unit\n");
    COMMON_CONFIG_SHOW_INT(storio_fidctx_ctx,256);
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("client_xattr_cache",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_BOOL(client_xattr_cache,False);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// When that flag is asserted, the rozofsmount client can cache the extended attributes\n");
    COMMON_CONFIG_SHOW_BOOL(client_xattr_cache,False);
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("async_setattr",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_BOOL(async_setattr,False);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// When that flag is asserted, the rozofsmount client performs setattr in asynchronous mode\n");
    COMMON_CONFIG_SHOW_BOOL(async_setattr,False);
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("statfs_period",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(statfs_period,10);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// statfs period in seconds. minimum is 0.\n");
    COMMON_CONFIG_SHOW_INT(statfs_period,10);
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("spare_restore_spare_ctx",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(spare_restore_spare_ctx,16);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// Spare file restoring : Number of spare file context in 1K unit\n");
    COMMON_CONFIG_SHOW_INT(spare_restore_spare_ctx,16);
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("min_metadata_inodes",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(min_metadata_inodes,262144);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// Minimum number of inodes that must be available on metadata device to allow a mknod/mkdir operation\n");
    COMMON_CONFIG_SHOW_INT(min_metadata_inodes,262144);
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("min_metadata_MB",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(min_metadata_MB,2048);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// Minimum available size in MB that must be available on metadata device to allow a mknod/mkdir operation\n");
    COMMON_CONFIG_SHOW_INT(min_metadata_MB,2048);
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("nb_trash_thread",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(nb_trash_thread,2);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// Number of trash threads that work in parallel\n");
    COMMON_CONFIG_SHOW_INT_OPT(nb_trash_thread,2,"1:8");
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("nb_thin_thread",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(nb_thin_thread,2);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// Number of thin provisioning threads that work in parallel\n");
    COMMON_CONFIG_SHOW_INT_OPT(nb_thin_thread,2,"1:4");
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("thin_scan_file_per_run",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(thin_scan_file_per_run,1000);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// Max number of files that the exportd can submit to storages to get the number of blocks (thin provisioning) in a run.\n");
    pChar += rozofs_string_append(pChar,"// A new run occurs every 2 seconds.\n");
    COMMON_CONFIG_SHOW_INT(thin_scan_file_per_run,1000);
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("thin_lv1_hash_tb_size",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(thin_lv1_hash_tb_size,10);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// Thin provisioning Level 1 hash table size in power of 2 (changing this parameter will take effect on the next export restart) \n");
    COMMON_CONFIG_SHOW_INT_OPT(thin_lv1_hash_tb_size,10,"6:128");
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("expthin_guard_delay_sec",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(expthin_guard_delay_sec,10);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// Guard delay in seconds between two file scanning of a file that belongs to an exportd configured for thin provisioning\n");
    COMMON_CONFIG_SHOW_INT_OPT(expthin_guard_delay_sec,10,"1:600");
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("rdma_enable",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_BOOL(rdma_enable,False);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// When that flag is asserted, the storcli uses RDMA when storio supports it\n");
    COMMON_CONFIG_SHOW_BOOL(rdma_enable,False);
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("rdma_full",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_BOOL(rdma_full,False);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// When that flag is asserted, the storcli uses RDMA for data transfer and RPC messages\n");
    COMMON_CONFIG_SHOW_BOOL(rdma_full,False);
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("min_rmda_size_KB",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(min_rmda_size_KB,64);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// Minimum read/write size in KB to trigger RDMA transfer\n");
    COMMON_CONFIG_SHOW_INT(min_rmda_size_KB,64);
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("rdma_delay_ms",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(rdma_delay_ms,0);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// RDMA write dequeue delay: delay in ms before dequeueing a new request (for network with latency)\n");
    COMMON_CONFIG_SHOW_INT(rdma_delay_ms,0);
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("rdma_delay_threshold",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(rdma_delay_threshold,12);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// RDMA write dequeue delay: threshold when reached that prevents RDMA delay to be called\n");
    COMMON_CONFIG_SHOW_INT_OPT(rdma_delay_threshold,12,"0:64");
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("mojette_thread_count",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(mojette_thread_count,4);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// number of Mojette threads\n");
    COMMON_CONFIG_SHOW_INT_OPT(mojette_thread_count,4,"1:4");
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("reply_thread_count",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(reply_thread_count,2);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// number of Fuse threads\n");
    COMMON_CONFIG_SHOW_INT_OPT(reply_thread_count,2,"1:8");
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("bufread_bypass",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_BOOL(bufread_bypass,False);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// Buffer read by-pass\n");
    COMMON_CONFIG_SHOW_BOOL(bufread_bypass,False);
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("expdir_guard_delay_sec",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(expdir_guard_delay_sec,10);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// Guard delay associated with directory re-write used for tracking children changes within a directory \n");
    COMMON_CONFIG_SHOW_INT_OPT(expdir_guard_delay_sec,10,"1:7200");
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("level2_cache_max_entries_kb",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(level2_cache_max_entries_kb,512);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// Maximum number of entries that the export level 2 cache can contain (unit is KB) \n");
    COMMON_CONFIG_SHOW_INT_OPT(level2_cache_max_entries_kb,512,"1:4096");
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("standalone",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_BOOL(standalone,False);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// When that flag is asserted, RozoFS operates in standalone mode only.\n");
    COMMON_CONFIG_SHOW_BOOL(standalone,False);
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("persistent_file_locks",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_BOOL(persistent_file_locks,False);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// Whether file locks must be persistent on exportd restart/switchover or not\n");
    COMMON_CONFIG_SHOW_BOOL(persistent_file_locks,False);
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("minimum_free_size_percent",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(minimum_free_size_percent,4);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// Minimum % of free space in a volume.\n");
    pChar += rozofs_string_append(pChar,"// When the free space of a volume reaches this value, file creation requests\n");
    pChar += rozofs_string_append(pChar,"// receive back ENOSPC in order to try to avoid later write errors.\n");
    pChar += rozofs_string_append(pChar,"// A value of 0 means there is no limit on the volume.\n");
    pChar += rozofs_string_append(pChar,"// A value of 100 forbids every file creation.\n");
    COMMON_CONFIG_SHOW_INT_OPT(minimum_free_size_percent,4,"0:100");
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("mandatory_device_label",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_BOOL(mandatory_device_label,False);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// Whether RozoFS devices must mandatorily be identified by a valid label.\n");
    pChar += rozofs_string_append(pChar,"// Storages will not mount any device not having a valid RozoFS label.\n");
    COMMON_CONFIG_SHOW_BOOL(mandatory_device_label,False);
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("storcli_read_parallel",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_BOOL(storcli_read_parallel,False);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// When that flag is asserted any storcli can be selected for reading.\n");
    COMMON_CONFIG_SHOW_BOOL(storcli_read_parallel,False);
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("diagnostic_mode",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_ENUM(diagnostic_mode,"both");
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// rozodiag mode\n");
    pChar += rozofs_string_append(pChar,"// server     Each RozoFS module listen for rozodiag command on its dedicated server port\n");
    pChar += rozofs_string_append(pChar,"// client     Each RozoFS module is client of a local rozodiag server that relays rozodiag commands\n");
    pChar += rozofs_string_append(pChar,"// both       Each RozoFS module is client as well as server\n");
    pChar += rozofs_string_append(pChar,"//    \n");
    COMMON_CONFIG_SHOW_ENUM(diagnostic_mode,""both"","both,server,client");
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("expbt_active",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_BOOL(expbt_active,False);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// Whether export file tracking reader for rozofsmount batch is enabled\n");
    COMMON_CONFIG_SHOW_BOOL(expbt_active,False);
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("nb_expbt_thread",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(nb_expbt_thread,4);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"/// Number of file tracking reader threads.\n");
    COMMON_CONFIG_SHOW_INT_OPT(nb_expbt_thread,4,"2:32");
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("expbt_buf_cnt",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(expbt_buf_cnt,32);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// Number of STORIO receive buffer.\n");
    COMMON_CONFIG_SHOW_INT_OPT(expbt_buf_cnt,32,"8:128");
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("dirent_cache_size",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(dirent_cache_size,250000);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// Max number of entries in the dirent and root bitmap caches\n");
    COMMON_CONFIG_SHOW_INT_OPT(dirent_cache_size,250000,"2:500000");
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("dirent_garbage_delay",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(dirent_garbage_delay,5);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// retention delay before memory release for dirent and bitmap entries in cache (seconds)\n");
    COMMON_CONFIG_SHOW_INT_OPT(dirent_garbage_delay,5,"1:60");
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("trk_cache_size",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(trk_cache_size,2048);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// Max number of entries in tracking file cache\n");
    COMMON_CONFIG_SHOW_INT_OPT(trk_cache_size,2048,"32:8192");
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("trk_garbage_delay",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(trk_garbage_delay,5);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// retention delay before memory release in tracking file cache (seconds)\n");
    COMMON_CONFIG_SHOW_INT_OPT(trk_garbage_delay,5,"1:60");
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }

  if (strcasestr("trk_expiration_delay",parameter) != NULL) {
    match++;
    COMMON_CONFIG_IS_DEFAULT_INT(trk_expiration_delay,120);
    if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
    pChar += rozofs_string_append(pChar,"// expiration delay of an entry of the tracking file cache (seconds)\n");
    COMMON_CONFIG_SHOW_INT_OPT(trk_expiration_delay,120,"4:600");
    if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  }
  if (match == 0) {
    pChar += rozofs_string_append_error(pChar,"No such parameter like ");
    pChar += rozofs_string_append_error(pChar,parameter);
    pChar += rozofs_eol(pChar);\
  }
  return match;
}
/*____________________________________________________________________________________________
**
** common_config man function
**
*/
void man_common_config(char * pChar) {
  pChar += rozofs_string_append_underscore(pChar,"\nUsage:\n");
  pChar += rozofs_string_append_bold(pChar,"\tcconf [long]");
  pChar += rozofs_string_append     (pChar,"\t\tdisplays the whole common_config configuration.\n");
  pChar += rozofs_string_append_bold(pChar,"\tcconf [long] <scope>");
  pChar += rozofs_string_append     (pChar,"\tdisplays only the <scope> configuration part.\n");
  pChar += rozofs_string_append_bold(pChar,"\tcconf search <parameter>");
  pChar += rozofs_string_append     (pChar,"\tdisplays parameters approximatively like <parameter>.\n");
  pChar += rozofs_string_append_bold(pChar,"\tcconf reload");
  pChar += rozofs_string_append     (pChar,"\treloads and then displays the configuration.\n");
  pChar += rozofs_string_append_bold(pChar,"\tcconf set <param> <value>");
  pChar += rozofs_string_append     (pChar,"\tmodifies a configuration parameter in memory.\n");
  pChar += rozofs_string_append_bold(pChar,"\tcconf save");
  pChar += rozofs_string_append     (pChar,"\tsaves configuration from memory to disk.\n");
  pChar += rozofs_string_append_bold(pChar,"\tcconf files");
  pChar += rozofs_string_append     (pChar,"\tReturns the name of the configuration file and the saved ones.\n");
}
/*____________________________________________________________________________________________
**
** global scope configuration parameters
**
*/
char * show_common_config_module_global(char * pChar) {

  pChar += rozofs_string_append_effect(pChar,"#                                                            \n#     ", ROZOFS_COLOR_BLUE ROZOFS_COLOR_BOLD ROZOFS_COLOR_REVERSE);
  pChar += rozofs_string_append_effect(pChar,"    GLOBAL SCOPE CONFIGURATION PARAMETERS         ", ROZOFS_COLOR_YELLOW ROZOFS_COLOR_BOLD ROZOFS_COLOR_REVERSE);
  pChar += rozofs_string_append_effect(pChar,"     \n#                                                            \n\n", ROZOFS_COLOR_BLUE ROZOFS_COLOR_BOLD ROZOFS_COLOR_REVERSE);

  COMMON_CONFIG_IS_DEFAULT_INT(nb_core_file,1);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// Number of core files that the system is allowed to keep for all the modules of this server.\n");
  pChar += rozofs_string_append(pChar,"// Older core files are kept while newest are removed.	\n");
  COMMON_CONFIG_SHOW_INT_OPT(nb_core_file,1,"0:8");
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_STRING(core_file_directory,"");
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// Directory where the core files are stored.\n");
  COMMON_CONFIG_SHOW_STRING(core_file_directory,"");
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_BOOL(numa_aware,False);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// Enables to take into account the NUMA architecture of the board in \n");
  pChar += rozofs_string_append(pChar,"// order to collocate some RozoFS modules on the same node for memory\n");
  pChar += rozofs_string_append(pChar,"// access efficiency.\n");
  COMMON_CONFIG_SHOW_BOOL(numa_aware,False);
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_INT(adaptor_numa_node,-1);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// Ethernet Adaptor numa node (-1 not significant)\n");
  COMMON_CONFIG_SHOW_INT(adaptor_numa_node,-1);
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_ENUM(processor_model,"INTEL");
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// processor model:\n");
  pChar += rozofs_string_append(pChar,"// EPYC: all AMD CPUs \n");
  pChar += rozofs_string_append(pChar,"// INTEL:   covers E5 & skylake families\n");
  COMMON_CONFIG_SHOW_ENUM(processor_model,""INTEL"","EPYC,INTEL");
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_INT(storio_slice_number,1024);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// Number of slices in the STORIO.\n");
  COMMON_CONFIG_SHOW_INT_OPT(storio_slice_number,1024,"8:(32*1024)");
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_INT(file_distribution_rule,0);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// File distribution mode upon cluster, storages and devices. Check rozofs.conf manual.\n");
  pChar += rozofs_string_append(pChar,"// 0         = Cluster size balancing                   + device size balancing\n");
  pChar += rozofs_string_append(pChar,"// 1,2,3     = Cluster strict round robin               + device write spreading\n");
  pChar += rozofs_string_append(pChar,"// 4         = Cluster strict round robin               + device read spreading\n");
  pChar += rozofs_string_append(pChar,"// 5         = Cluster weighted round robin (nb SID)    + device write spreading\n");
  pChar += rozofs_string_append(pChar,"// 6         = Cluster weighted round robin (nb SID)    + device read spreading\n");
  pChar += rozofs_string_append(pChar,"// 7         = Cluster weighted round robin (free size) + device write spreading\n");
  pChar += rozofs_string_append(pChar,"// 6         = Cluster weighted round robin (free size) + device read spreading\n");
  COMMON_CONFIG_SHOW_INT_OPT(file_distribution_rule,0,"0:100");
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_INT(storio_dscp,46);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// DSCP for exchanges from/to the STORIO.\n");
  COMMON_CONFIG_SHOW_INT_OPT(storio_dscp,46,"0:46");
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_INT(export_dscp,34);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// DSCP for exchanges from/to the EXPORTD.\n");
  COMMON_CONFIG_SHOW_INT_OPT(export_dscp,34,"0:34");
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_BOOL(standalone,False);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// When that flag is asserted, RozoFS operates in standalone mode only.\n");
  COMMON_CONFIG_SHOW_BOOL(standalone,False);
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_ENUM(diagnostic_mode,"both");
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// rozodiag mode\n");
  pChar += rozofs_string_append(pChar,"// server     Each RozoFS module listen for rozodiag command on its dedicated server port\n");
  pChar += rozofs_string_append(pChar,"// client     Each RozoFS module is client of a local rozodiag server that relays rozodiag commands\n");
  pChar += rozofs_string_append(pChar,"// both       Each RozoFS module is client as well as server\n");
  pChar += rozofs_string_append(pChar,"//    \n");
  COMMON_CONFIG_SHOW_ENUM(diagnostic_mode,""both"","both,server,client");
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  return pChar;
}
/*____________________________________________________________________________________________
**
** global scope configuration parameters
**
*/
char * show_common_config_module_global_short(char * pChar) {

  pChar += rozofs_string_append_effect(pChar,"#                                                            \n#     ", ROZOFS_COLOR_BLUE ROZOFS_COLOR_BOLD ROZOFS_COLOR_REVERSE);
  pChar += rozofs_string_append_effect(pChar,"    GLOBAL SCOPE CONFIGURATION PARAMETERS         ", ROZOFS_COLOR_YELLOW ROZOFS_COLOR_BOLD ROZOFS_COLOR_REVERSE);
  pChar += rozofs_string_append_effect(pChar,"     \n#                                                            \n\n", ROZOFS_COLOR_BLUE ROZOFS_COLOR_BOLD ROZOFS_COLOR_REVERSE);


  COMMON_CONFIG_IS_DEFAULT_INT(nb_core_file,1);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Number of core files that the system is allowed to keep for all the modules of this server.\n");
    pChar += rozofs_string_append(pChar,"// Older core files are kept while newest are removed.	\n");
    COMMON_CONFIG_SHOW_INT_OPT(nb_core_file,1,"0:8");
  }


  COMMON_CONFIG_IS_DEFAULT_STRING(core_file_directory,"");
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Directory where the core files are stored.\n");
    COMMON_CONFIG_SHOW_STRING(core_file_directory,"");
  }


  COMMON_CONFIG_IS_DEFAULT_BOOL(numa_aware,False);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Enables to take into account the NUMA architecture of the board in \n");
    pChar += rozofs_string_append(pChar,"// order to collocate some RozoFS modules on the same node for memory\n");
    pChar += rozofs_string_append(pChar,"// access efficiency.\n");
    COMMON_CONFIG_SHOW_BOOL(numa_aware,False);
  }


  COMMON_CONFIG_IS_DEFAULT_INT(adaptor_numa_node,-1);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Ethernet Adaptor numa node (-1 not significant)\n");
    COMMON_CONFIG_SHOW_INT(adaptor_numa_node,-1);
  }


  COMMON_CONFIG_IS_DEFAULT_ENUM(processor_model,"INTEL");
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// processor model:\n");
    pChar += rozofs_string_append(pChar,"// EPYC: all AMD CPUs \n");
    pChar += rozofs_string_append(pChar,"// INTEL:   covers E5 & skylake families\n");
    COMMON_CONFIG_SHOW_ENUM(processor_model,"INTEL","EPYC,INTEL");
  }


  COMMON_CONFIG_IS_DEFAULT_INT(storio_slice_number,1024);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Number of slices in the STORIO.\n");
    COMMON_CONFIG_SHOW_INT_OPT(storio_slice_number,1024,"8:(32*1024)");
  }


  COMMON_CONFIG_IS_DEFAULT_INT(file_distribution_rule,0);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// File distribution mode upon cluster, storages and devices. Check rozofs.conf manual.\n");
    pChar += rozofs_string_append(pChar,"// 0         = Cluster size balancing                   + device size balancing\n");
    pChar += rozofs_string_append(pChar,"// 1,2,3     = Cluster strict round robin               + device write spreading\n");
    pChar += rozofs_string_append(pChar,"// 4         = Cluster strict round robin               + device read spreading\n");
    pChar += rozofs_string_append(pChar,"// 5         = Cluster weighted round robin (nb SID)    + device write spreading\n");
    pChar += rozofs_string_append(pChar,"// 6         = Cluster weighted round robin (nb SID)    + device read spreading\n");
    pChar += rozofs_string_append(pChar,"// 7         = Cluster weighted round robin (free size) + device write spreading\n");
    pChar += rozofs_string_append(pChar,"// 6         = Cluster weighted round robin (free size) + device read spreading\n");
    COMMON_CONFIG_SHOW_INT_OPT(file_distribution_rule,0,"0:100");
  }


  COMMON_CONFIG_IS_DEFAULT_INT(storio_dscp,46);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// DSCP for exchanges from/to the STORIO.\n");
    COMMON_CONFIG_SHOW_INT_OPT(storio_dscp,46,"0:46");
  }


  COMMON_CONFIG_IS_DEFAULT_INT(export_dscp,34);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// DSCP for exchanges from/to the EXPORTD.\n");
    COMMON_CONFIG_SHOW_INT_OPT(export_dscp,34,"0:34");
  }


  COMMON_CONFIG_IS_DEFAULT_BOOL(standalone,False);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// When that flag is asserted, RozoFS operates in standalone mode only.\n");
    COMMON_CONFIG_SHOW_BOOL(standalone,False);
  }


  COMMON_CONFIG_IS_DEFAULT_ENUM(diagnostic_mode,"both");
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// rozodiag mode\n");
    pChar += rozofs_string_append(pChar,"// server     Each RozoFS module listen for rozodiag command on its dedicated server port\n");
    pChar += rozofs_string_append(pChar,"// client     Each RozoFS module is client of a local rozodiag server that relays rozodiag commands\n");
    pChar += rozofs_string_append(pChar,"// both       Each RozoFS module is client as well as server\n");
    pChar += rozofs_string_append(pChar,"//    \n");
    COMMON_CONFIG_SHOW_ENUM(diagnostic_mode,"both","both,server,client");
  }
  return pChar;
}
/*____________________________________________________________________________________________
**
** export scope configuration parameters
**
*/
char * show_common_config_module_export(char * pChar) {

  pChar += rozofs_string_append_effect(pChar,"#                                                            \n#     ", ROZOFS_COLOR_BLUE ROZOFS_COLOR_BOLD ROZOFS_COLOR_REVERSE);
  pChar += rozofs_string_append_effect(pChar,"    EXPORT SCOPE CONFIGURATION PARAMETERS         ", ROZOFS_COLOR_YELLOW ROZOFS_COLOR_BOLD ROZOFS_COLOR_REVERSE);
  pChar += rozofs_string_append_effect(pChar,"     \n#                                                            \n\n", ROZOFS_COLOR_BLUE ROZOFS_COLOR_BOLD ROZOFS_COLOR_REVERSE);

  COMMON_CONFIG_IS_DEFAULT_INT(trashed_file_per_run,1000);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// Max number of file that the exportd can remove from storages in a run.\n");
  pChar += rozofs_string_append(pChar,"// A new run occurs every 2 seconds.\n");
  COMMON_CONFIG_SHOW_INT(trashed_file_per_run,1000);
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_INT(trash_high_threshold,1000);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// High trash water mark when FID recycling is activated.\n");
  pChar += rozofs_string_append(pChar,"// When the trash has already this number of files, files are no more\n");
  pChar += rozofs_string_append(pChar,"// deleted but recycled.\n");
  COMMON_CONFIG_SHOW_INT_OPT(trash_high_threshold,1000,"0:1000000");
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_BOOL(fid_recycle,False);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// Whether FID recycling feature is activated.\n");
  COMMON_CONFIG_SHOW_BOOL(fid_recycle,False);
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_INT(export_buf_cnt,128);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  COMMON_CONFIG_SHOW_INT_OPT(export_buf_cnt,128,"32:1024");
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_BOOL(export_attr_thread,True);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// To activate export writebehind attributes thread.\n");
  COMMON_CONFIG_SHOW_BOOL(export_attr_thread,True);
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_BOOL(export_versioning,False);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// Support of deleted directory/file versioning.\n");
  COMMON_CONFIG_SHOW_BOOL(export_versioning,False);
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_INT(alloc_estimated_mb,1);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// Number of MB to account a file for during file distribution phase\n");
  COMMON_CONFIG_SHOW_INT(alloc_estimated_mb,1);
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_INT(client_flock_timeout,30);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// Delay from which a rozofsmoun client is declared disconnected and its \n");
  pChar += rozofs_string_append(pChar,"// file locks are automatically removed\n");
  COMMON_CONFIG_SHOW_INT_OPT(client_flock_timeout,30,"15:600");
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_INT(mproto_timeout,10);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// Time out between export and storage for remove and stat\n");
  COMMON_CONFIG_SHOW_INT_OPT(mproto_timeout,10,"1:60");
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_STRING(export_temporary_dir,"/tmp");
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// Directory to use on the export to build temporary files.\n");
  pChar += rozofs_string_append(pChar,"// Used for instance to build list of files to rebuild.\n");
  COMMON_CONFIG_SHOW_STRING(export_temporary_dir,"/tmp");
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_BOOL(mkdir_ok_instead_of_eexist,False);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// To activate workaround that make mkdir respond OK instead of EEXIST\n");
  pChar += rozofs_string_append(pChar,"// when the directory is already created \n");
  COMMON_CONFIG_SHOW_BOOL(mkdir_ok_instead_of_eexist,False);
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_BOOL(mknod_ok_instead_of_eexist,False);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// To activate workaround that make mknod respond OK instead of EEXIST\n");
  pChar += rozofs_string_append(pChar,"// when the file is already created  \n");
  COMMON_CONFIG_SHOW_BOOL(mknod_ok_instead_of_eexist,False);
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_BOOL(disable_sync_attributes,False);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// To disable synchronous write of attributes when set to True\n");
  COMMON_CONFIG_SHOW_BOOL(disable_sync_attributes,False);
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_INT(deletion_delay,30);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// Minimum delay between the deletion request and the effective projections deletion\n");
  COMMON_CONFIG_SHOW_INT(deletion_delay,30);
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_INT(min_metadata_inodes,262144);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// Minimum number of inodes that must be available on metadata device to allow a mknod/mkdir operation\n");
  COMMON_CONFIG_SHOW_INT(min_metadata_inodes,262144);
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_INT(min_metadata_MB,2048);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// Minimum available size in MB that must be available on metadata device to allow a mknod/mkdir operation\n");
  COMMON_CONFIG_SHOW_INT(min_metadata_MB,2048);
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_INT(nb_trash_thread,2);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// Number of trash threads that work in parallel\n");
  COMMON_CONFIG_SHOW_INT_OPT(nb_trash_thread,2,"1:8");
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_INT(nb_thin_thread,2);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// Number of thin provisioning threads that work in parallel\n");
  COMMON_CONFIG_SHOW_INT_OPT(nb_thin_thread,2,"1:4");
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_INT(thin_scan_file_per_run,1000);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// Max number of files that the exportd can submit to storages to get the number of blocks (thin provisioning) in a run.\n");
  pChar += rozofs_string_append(pChar,"// A new run occurs every 2 seconds.\n");
  COMMON_CONFIG_SHOW_INT(thin_scan_file_per_run,1000);
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_INT(thin_lv1_hash_tb_size,10);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// Thin provisioning Level 1 hash table size in power of 2 (changing this parameter will take effect on the next export restart) \n");
  COMMON_CONFIG_SHOW_INT_OPT(thin_lv1_hash_tb_size,10,"6:128");
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_INT(expthin_guard_delay_sec,10);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// Guard delay in seconds between two file scanning of a file that belongs to an exportd configured for thin provisioning\n");
  COMMON_CONFIG_SHOW_INT_OPT(expthin_guard_delay_sec,10,"1:600");
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_INT(expdir_guard_delay_sec,10);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// Guard delay associated with directory re-write used for tracking children changes within a directory \n");
  COMMON_CONFIG_SHOW_INT_OPT(expdir_guard_delay_sec,10,"1:7200");
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_INT(level2_cache_max_entries_kb,512);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// Maximum number of entries that the export level 2 cache can contain (unit is KB) \n");
  COMMON_CONFIG_SHOW_INT_OPT(level2_cache_max_entries_kb,512,"1:4096");
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_BOOL(persistent_file_locks,False);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// Whether file locks must be persistent on exportd restart/switchover or not\n");
  COMMON_CONFIG_SHOW_BOOL(persistent_file_locks,False);
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_INT(minimum_free_size_percent,4);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// Minimum % of free space in a volume.\n");
  pChar += rozofs_string_append(pChar,"// When the free space of a volume reaches this value, file creation requests\n");
  pChar += rozofs_string_append(pChar,"// receive back ENOSPC in order to try to avoid later write errors.\n");
  pChar += rozofs_string_append(pChar,"// A value of 0 means there is no limit on the volume.\n");
  pChar += rozofs_string_append(pChar,"// A value of 100 forbids every file creation.\n");
  COMMON_CONFIG_SHOW_INT_OPT(minimum_free_size_percent,4,"0:100");
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  return pChar;
}
/*____________________________________________________________________________________________
**
** export scope configuration parameters
**
*/
char * show_common_config_module_export_short(char * pChar) {

  pChar += rozofs_string_append_effect(pChar,"#                                                            \n#     ", ROZOFS_COLOR_BLUE ROZOFS_COLOR_BOLD ROZOFS_COLOR_REVERSE);
  pChar += rozofs_string_append_effect(pChar,"    EXPORT SCOPE CONFIGURATION PARAMETERS         ", ROZOFS_COLOR_YELLOW ROZOFS_COLOR_BOLD ROZOFS_COLOR_REVERSE);
  pChar += rozofs_string_append_effect(pChar,"     \n#                                                            \n\n", ROZOFS_COLOR_BLUE ROZOFS_COLOR_BOLD ROZOFS_COLOR_REVERSE);


  COMMON_CONFIG_IS_DEFAULT_INT(trashed_file_per_run,1000);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Max number of file that the exportd can remove from storages in a run.\n");
    pChar += rozofs_string_append(pChar,"// A new run occurs every 2 seconds.\n");
    COMMON_CONFIG_SHOW_INT(trashed_file_per_run,1000);
  }


  COMMON_CONFIG_IS_DEFAULT_INT(trash_high_threshold,1000);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// High trash water mark when FID recycling is activated.\n");
    pChar += rozofs_string_append(pChar,"// When the trash has already this number of files, files are no more\n");
    pChar += rozofs_string_append(pChar,"// deleted but recycled.\n");
    COMMON_CONFIG_SHOW_INT_OPT(trash_high_threshold,1000,"0:1000000");
  }


  COMMON_CONFIG_IS_DEFAULT_BOOL(fid_recycle,False);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Whether FID recycling feature is activated.\n");
    COMMON_CONFIG_SHOW_BOOL(fid_recycle,False);
  }


  COMMON_CONFIG_IS_DEFAULT_INT(export_buf_cnt,128);
  if (isDefaultValue==0) {
    COMMON_CONFIG_SHOW_INT_OPT(export_buf_cnt,128,"32:1024");
  }


  COMMON_CONFIG_IS_DEFAULT_BOOL(export_attr_thread,True);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// To activate export writebehind attributes thread.\n");
    COMMON_CONFIG_SHOW_BOOL(export_attr_thread,True);
  }


  COMMON_CONFIG_IS_DEFAULT_BOOL(export_versioning,False);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Support of deleted directory/file versioning.\n");
    COMMON_CONFIG_SHOW_BOOL(export_versioning,False);
  }


  COMMON_CONFIG_IS_DEFAULT_INT(alloc_estimated_mb,1);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Number of MB to account a file for during file distribution phase\n");
    COMMON_CONFIG_SHOW_INT(alloc_estimated_mb,1);
  }


  COMMON_CONFIG_IS_DEFAULT_INT(client_flock_timeout,30);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Delay from which a rozofsmoun client is declared disconnected and its \n");
    pChar += rozofs_string_append(pChar,"// file locks are automatically removed\n");
    COMMON_CONFIG_SHOW_INT_OPT(client_flock_timeout,30,"15:600");
  }


  COMMON_CONFIG_IS_DEFAULT_INT(mproto_timeout,10);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Time out between export and storage for remove and stat\n");
    COMMON_CONFIG_SHOW_INT_OPT(mproto_timeout,10,"1:60");
  }


  COMMON_CONFIG_IS_DEFAULT_STRING(export_temporary_dir,"/tmp");
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Directory to use on the export to build temporary files.\n");
    pChar += rozofs_string_append(pChar,"// Used for instance to build list of files to rebuild.\n");
    COMMON_CONFIG_SHOW_STRING(export_temporary_dir,"/tmp");
  }


  COMMON_CONFIG_IS_DEFAULT_BOOL(mkdir_ok_instead_of_eexist,False);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// To activate workaround that make mkdir respond OK instead of EEXIST\n");
    pChar += rozofs_string_append(pChar,"// when the directory is already created \n");
    COMMON_CONFIG_SHOW_BOOL(mkdir_ok_instead_of_eexist,False);
  }


  COMMON_CONFIG_IS_DEFAULT_BOOL(mknod_ok_instead_of_eexist,False);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// To activate workaround that make mknod respond OK instead of EEXIST\n");
    pChar += rozofs_string_append(pChar,"// when the file is already created  \n");
    COMMON_CONFIG_SHOW_BOOL(mknod_ok_instead_of_eexist,False);
  }


  COMMON_CONFIG_IS_DEFAULT_BOOL(disable_sync_attributes,False);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// To disable synchronous write of attributes when set to True\n");
    COMMON_CONFIG_SHOW_BOOL(disable_sync_attributes,False);
  }


  COMMON_CONFIG_IS_DEFAULT_INT(deletion_delay,30);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Minimum delay between the deletion request and the effective projections deletion\n");
    COMMON_CONFIG_SHOW_INT(deletion_delay,30);
  }


  COMMON_CONFIG_IS_DEFAULT_INT(min_metadata_inodes,262144);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Minimum number of inodes that must be available on metadata device to allow a mknod/mkdir operation\n");
    COMMON_CONFIG_SHOW_INT(min_metadata_inodes,262144);
  }


  COMMON_CONFIG_IS_DEFAULT_INT(min_metadata_MB,2048);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Minimum available size in MB that must be available on metadata device to allow a mknod/mkdir operation\n");
    COMMON_CONFIG_SHOW_INT(min_metadata_MB,2048);
  }


  COMMON_CONFIG_IS_DEFAULT_INT(nb_trash_thread,2);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Number of trash threads that work in parallel\n");
    COMMON_CONFIG_SHOW_INT_OPT(nb_trash_thread,2,"1:8");
  }


  COMMON_CONFIG_IS_DEFAULT_INT(nb_thin_thread,2);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Number of thin provisioning threads that work in parallel\n");
    COMMON_CONFIG_SHOW_INT_OPT(nb_thin_thread,2,"1:4");
  }


  COMMON_CONFIG_IS_DEFAULT_INT(thin_scan_file_per_run,1000);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Max number of files that the exportd can submit to storages to get the number of blocks (thin provisioning) in a run.\n");
    pChar += rozofs_string_append(pChar,"// A new run occurs every 2 seconds.\n");
    COMMON_CONFIG_SHOW_INT(thin_scan_file_per_run,1000);
  }


  COMMON_CONFIG_IS_DEFAULT_INT(thin_lv1_hash_tb_size,10);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Thin provisioning Level 1 hash table size in power of 2 (changing this parameter will take effect on the next export restart) \n");
    COMMON_CONFIG_SHOW_INT_OPT(thin_lv1_hash_tb_size,10,"6:128");
  }


  COMMON_CONFIG_IS_DEFAULT_INT(expthin_guard_delay_sec,10);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Guard delay in seconds between two file scanning of a file that belongs to an exportd configured for thin provisioning\n");
    COMMON_CONFIG_SHOW_INT_OPT(expthin_guard_delay_sec,10,"1:600");
  }


  COMMON_CONFIG_IS_DEFAULT_INT(expdir_guard_delay_sec,10);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Guard delay associated with directory re-write used for tracking children changes within a directory \n");
    COMMON_CONFIG_SHOW_INT_OPT(expdir_guard_delay_sec,10,"1:7200");
  }


  COMMON_CONFIG_IS_DEFAULT_INT(level2_cache_max_entries_kb,512);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Maximum number of entries that the export level 2 cache can contain (unit is KB) \n");
    COMMON_CONFIG_SHOW_INT_OPT(level2_cache_max_entries_kb,512,"1:4096");
  }


  COMMON_CONFIG_IS_DEFAULT_BOOL(persistent_file_locks,False);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Whether file locks must be persistent on exportd restart/switchover or not\n");
    COMMON_CONFIG_SHOW_BOOL(persistent_file_locks,False);
  }


  COMMON_CONFIG_IS_DEFAULT_INT(minimum_free_size_percent,4);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Minimum % of free space in a volume.\n");
    pChar += rozofs_string_append(pChar,"// When the free space of a volume reaches this value, file creation requests\n");
    pChar += rozofs_string_append(pChar,"// receive back ENOSPC in order to try to avoid later write errors.\n");
    pChar += rozofs_string_append(pChar,"// A value of 0 means there is no limit on the volume.\n");
    pChar += rozofs_string_append(pChar,"// A value of 100 forbids every file creation.\n");
    COMMON_CONFIG_SHOW_INT_OPT(minimum_free_size_percent,4,"0:100");
  }
  return pChar;
}
/*____________________________________________________________________________________________
**
** client scope configuration parameters
**
*/
char * show_common_config_module_client(char * pChar) {

  pChar += rozofs_string_append_effect(pChar,"#                                                            \n#     ", ROZOFS_COLOR_BLUE ROZOFS_COLOR_BOLD ROZOFS_COLOR_REVERSE);
  pChar += rozofs_string_append_effect(pChar,"    CLIENT SCOPE CONFIGURATION PARAMETERS         ", ROZOFS_COLOR_YELLOW ROZOFS_COLOR_BOLD ROZOFS_COLOR_REVERSE);
  pChar += rozofs_string_append_effect(pChar,"     \n#                                                            \n\n", ROZOFS_COLOR_BLUE ROZOFS_COLOR_BOLD ROZOFS_COLOR_REVERSE);

  COMMON_CONFIG_IS_DEFAULT_BOOL(wr_ack_on_inverse,False);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// Whether STORCLI acknowleges write request on inverse or forward STORIO responses.\n");
  COMMON_CONFIG_SHOW_BOOL(wr_ack_on_inverse,False);
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_BOOL(wr_pending_anticipated,False);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// To indicate if we can respond before write_pending reaches 0.\n");
  COMMON_CONFIG_SHOW_BOOL(wr_pending_anticipated,False);
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_INT(rozofsmount_fuse_reply_thread,0);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// To activate rozofsmount reply fuse threads.\n");
  COMMON_CONFIG_SHOW_INT_OPT(rozofsmount_fuse_reply_thread,0,"0:4");
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_BOOL(client_fast_reconnect,False);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// To activate fast reconnect from client to exportd\n");
  COMMON_CONFIG_SHOW_BOOL(client_fast_reconnect,False);
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_INT(archive_file_delay,10);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// delay is minutes after which a file is considered as an archived file (unit is minute)\n");
  COMMON_CONFIG_SHOW_INT_OPT(archive_file_delay,10,"0:3600");
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_INT(archive_file_dentry_timeout,30);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// dentry cache timeout for archive file type (unit is second)\n");
  COMMON_CONFIG_SHOW_INT_OPT(archive_file_dentry_timeout,30,"0:300");
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_INT(archive_file_attr_timeout,30);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// attribute cache timeout for archive file type (unit is second)\n");
  COMMON_CONFIG_SHOW_INT_OPT(archive_file_attr_timeout,30,"0:300");
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_BOOL(client_xattr_cache,False);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// When that flag is asserted, the rozofsmount client can cache the extended attributes\n");
  COMMON_CONFIG_SHOW_BOOL(client_xattr_cache,False);
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_BOOL(async_setattr,False);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// When that flag is asserted, the rozofsmount client performs setattr in asynchronous mode\n");
  COMMON_CONFIG_SHOW_BOOL(async_setattr,False);
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_INT(statfs_period,10);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// statfs period in seconds. minimum is 0.\n");
  COMMON_CONFIG_SHOW_INT(statfs_period,10);
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_INT(reply_thread_count,2);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// number of Fuse threads\n");
  COMMON_CONFIG_SHOW_INT_OPT(reply_thread_count,2,"1:8");
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_BOOL(bufread_bypass,False);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// Buffer read by-pass\n");
  COMMON_CONFIG_SHOW_BOOL(bufread_bypass,False);
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_BOOL(storcli_read_parallel,False);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// When that flag is asserted any storcli can be selected for reading.\n");
  COMMON_CONFIG_SHOW_BOOL(storcli_read_parallel,False);
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  return pChar;
}
/*____________________________________________________________________________________________
**
** client scope configuration parameters
**
*/
char * show_common_config_module_client_short(char * pChar) {

  pChar += rozofs_string_append_effect(pChar,"#                                                            \n#     ", ROZOFS_COLOR_BLUE ROZOFS_COLOR_BOLD ROZOFS_COLOR_REVERSE);
  pChar += rozofs_string_append_effect(pChar,"    CLIENT SCOPE CONFIGURATION PARAMETERS         ", ROZOFS_COLOR_YELLOW ROZOFS_COLOR_BOLD ROZOFS_COLOR_REVERSE);
  pChar += rozofs_string_append_effect(pChar,"     \n#                                                            \n\n", ROZOFS_COLOR_BLUE ROZOFS_COLOR_BOLD ROZOFS_COLOR_REVERSE);


  COMMON_CONFIG_IS_DEFAULT_BOOL(wr_ack_on_inverse,False);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Whether STORCLI acknowleges write request on inverse or forward STORIO responses.\n");
    COMMON_CONFIG_SHOW_BOOL(wr_ack_on_inverse,False);
  }


  COMMON_CONFIG_IS_DEFAULT_BOOL(wr_pending_anticipated,False);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// To indicate if we can respond before write_pending reaches 0.\n");
    COMMON_CONFIG_SHOW_BOOL(wr_pending_anticipated,False);
  }


  COMMON_CONFIG_IS_DEFAULT_INT(rozofsmount_fuse_reply_thread,0);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// To activate rozofsmount reply fuse threads.\n");
    COMMON_CONFIG_SHOW_INT_OPT(rozofsmount_fuse_reply_thread,0,"0:4");
  }


  COMMON_CONFIG_IS_DEFAULT_BOOL(client_fast_reconnect,False);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// To activate fast reconnect from client to exportd\n");
    COMMON_CONFIG_SHOW_BOOL(client_fast_reconnect,False);
  }


  COMMON_CONFIG_IS_DEFAULT_INT(archive_file_delay,10);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// delay is minutes after which a file is considered as an archived file (unit is minute)\n");
    COMMON_CONFIG_SHOW_INT_OPT(archive_file_delay,10,"0:3600");
  }


  COMMON_CONFIG_IS_DEFAULT_INT(archive_file_dentry_timeout,30);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// dentry cache timeout for archive file type (unit is second)\n");
    COMMON_CONFIG_SHOW_INT_OPT(archive_file_dentry_timeout,30,"0:300");
  }


  COMMON_CONFIG_IS_DEFAULT_INT(archive_file_attr_timeout,30);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// attribute cache timeout for archive file type (unit is second)\n");
    COMMON_CONFIG_SHOW_INT_OPT(archive_file_attr_timeout,30,"0:300");
  }


  COMMON_CONFIG_IS_DEFAULT_BOOL(client_xattr_cache,False);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// When that flag is asserted, the rozofsmount client can cache the extended attributes\n");
    COMMON_CONFIG_SHOW_BOOL(client_xattr_cache,False);
  }


  COMMON_CONFIG_IS_DEFAULT_BOOL(async_setattr,False);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// When that flag is asserted, the rozofsmount client performs setattr in asynchronous mode\n");
    COMMON_CONFIG_SHOW_BOOL(async_setattr,False);
  }


  COMMON_CONFIG_IS_DEFAULT_INT(statfs_period,10);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// statfs period in seconds. minimum is 0.\n");
    COMMON_CONFIG_SHOW_INT(statfs_period,10);
  }


  COMMON_CONFIG_IS_DEFAULT_INT(reply_thread_count,2);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// number of Fuse threads\n");
    COMMON_CONFIG_SHOW_INT_OPT(reply_thread_count,2,"1:8");
  }


  COMMON_CONFIG_IS_DEFAULT_BOOL(bufread_bypass,False);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Buffer read by-pass\n");
    COMMON_CONFIG_SHOW_BOOL(bufread_bypass,False);
  }


  COMMON_CONFIG_IS_DEFAULT_BOOL(storcli_read_parallel,False);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// When that flag is asserted any storcli can be selected for reading.\n");
    COMMON_CONFIG_SHOW_BOOL(storcli_read_parallel,False);
  }
  return pChar;
}
/*____________________________________________________________________________________________
**
** storage scope configuration parameters
**
*/
char * show_common_config_module_storage(char * pChar) {

  pChar += rozofs_string_append_effect(pChar,"#                                                            \n#     ", ROZOFS_COLOR_BLUE ROZOFS_COLOR_BOLD ROZOFS_COLOR_REVERSE);
  pChar += rozofs_string_append_effect(pChar,"    STORAGE SCOPE CONFIGURATION PARAMETERS        ", ROZOFS_COLOR_YELLOW ROZOFS_COLOR_BOLD ROZOFS_COLOR_REVERSE);
  pChar += rozofs_string_append_effect(pChar,"     \n#                                                            \n\n", ROZOFS_COLOR_BLUE ROZOFS_COLOR_BOLD ROZOFS_COLOR_REVERSE);

  COMMON_CONFIG_IS_DEFAULT_INT(nb_storaged_subthread,8);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// Number of sub threads in the storaged\n");
  COMMON_CONFIG_SHOW_INT_OPT(nb_storaged_subthread,8,"2:16");
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_INT(nb_disk_thread,4);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"/// Number of disk threads in the STORIO.\n");
  COMMON_CONFIG_SHOW_INT_OPT(nb_disk_thread,4,"2:64");
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_INT(nb_write_rdma_threads,4);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"/// Number of RDMA write threads in the STORIO.\n");
  COMMON_CONFIG_SHOW_INT_OPT(nb_write_rdma_threads,4,"2:64");
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_BOOL(rdma_write_thread_enable,False);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// assert that Boolean to activate the RDMA write threads.\n");
  COMMON_CONFIG_SHOW_BOOL(rdma_write_thread_enable,False);
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_BOOL(crc32c_check,True);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// Whether CRC32 MUST be checked by STORIO.\n");
  COMMON_CONFIG_SHOW_BOOL(crc32c_check,True);
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_BOOL(crc32c_generate,True);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// Whether CRC32 MUST be computed by STORIO.\n");
  COMMON_CONFIG_SHOW_BOOL(crc32c_generate,True);
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_BOOL(crc32c_hw_forced,False);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// Whether CRC32 MUST be absolutly hardware computed by STORIO.\n");
  COMMON_CONFIG_SHOW_BOOL(crc32c_hw_forced,False);
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_BOOL(allow_disk_spin_down,False);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// Whether STORIO device monitoring should avoid reading from \n");
  pChar += rozofs_string_append(pChar,"// devices when no access have occured for read or write. This\n");
  pChar += rozofs_string_append(pChar,"// enables disk spin down to occur.\n");
  COMMON_CONFIG_SHOW_BOOL(allow_disk_spin_down,False);
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_INT(disk_usage_threshold,0);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// Over which device usage threashold should the STORIO log the event. \n");
  COMMON_CONFIG_SHOW_INT_OPT(disk_usage_threshold,0,"0:100");
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_INT(disk_read_threshold,0);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// Over which device read delay threashold should the STORIO log the event. \n");
  COMMON_CONFIG_SHOW_INT(disk_read_threshold,0);
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_INT(disk_write_threshold,0);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// Over which device write delay threashold should the STORIO log the event. \n");
  COMMON_CONFIG_SHOW_INT(disk_write_threshold,0);
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_INT(storio_buf_cnt,256);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// Number of STORIO receive buffer.\n");
  COMMON_CONFIG_SHOW_INT_OPT(storio_buf_cnt,256,"32:1024");
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_INT(recycle_truncate_blocks,0);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// Number of block to which the chunk files should be truncated on storage \n");
  pChar += rozofs_string_append(pChar,"// node at the time it is recycled.\n");
  COMMON_CONFIG_SHOW_INT(recycle_truncate_blocks,0);
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_STRING(storaged_start_script,"");
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// Name of an executable file that the storaged should call at startup\n");
  COMMON_CONFIG_SHOW_STRING(storaged_start_script,"");
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_BOOL(device_automount,False);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// Whether the storage has to automount the devices\n");
  COMMON_CONFIG_SHOW_BOOL(device_automount,False);
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_STRING(device_automount_path,"/srv/rozofs/storages");
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// automount path where the devices should be mounted\n");
  COMMON_CONFIG_SHOW_STRING(device_automount_path,"/srv/rozofs/storages");
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_STRING(device_automount_option,"");
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// Device mounting options\n");
  COMMON_CONFIG_SHOW_STRING(device_automount_option,"");
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_STRING(storage_temporary_dir,"/tmp");
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// Directory to use on the storage node to build temporary files.\n");
  pChar += rozofs_string_append(pChar,"// Used for instance by the rebuild process.\n");
  COMMON_CONFIG_SHOW_STRING(storage_temporary_dir,"/tmp");
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_INT(device_self_healing_process,8);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// self healing : Paralellism factor for device self healing feature\n");
  pChar += rozofs_string_append(pChar,"// i.e the number of process to run rebuild in //\n");
  COMMON_CONFIG_SHOW_INT_OPT(device_self_healing_process,8,"1:64");
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_INT(device_selfhealing_delay,15);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// self healing : Fault duration in minutes before device selfhealing starts\n");
  COMMON_CONFIG_SHOW_INT_OPT(device_selfhealing_delay,15,"0:10000");
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_INT(device_selfhealing_read_throughput,40);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// self healing :  throughput limitation in MB/s per rebuild process in //\n");
  pChar += rozofs_string_append(pChar,"// for reading external projections. The writing on disk is only\n");
  pChar += rozofs_string_append(pChar,"// 1/2 of that in layout 0, 1/4 in layout 1...\n");
  pChar += rozofs_string_append(pChar,"// 0 means no limit\n");
  COMMON_CONFIG_SHOW_INT_OPT(device_selfhealing_read_throughput,40,"0:10000");
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_ENUM(device_selfhealing_mode,"spareOnly");
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// self healing : possible modes\n");
  pChar += rozofs_string_append(pChar,"// spareOnly  only self repair on a spare disk\n");
  pChar += rozofs_string_append(pChar,"// relocate   also repair on remaining disks when no spare available\n");
  pChar += rozofs_string_append(pChar,"// resecure   repair on spare device when available, and then resecure files on\n");
  pChar += rozofs_string_append(pChar,"//            spare storages when no spare device is available\n");
  pChar += rozofs_string_append(pChar,"// none       No self healing is processed. Only manual rebuild is allowed.\n");
  COMMON_CONFIG_SHOW_ENUM(device_selfhealing_mode,""spareOnly"","spareOnly,resecure,relocate,none");
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_STRING(export_hosts,"");
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// Export host names or IP addresses separated with / \n");
  pChar += rozofs_string_append(pChar,"// Required for selfhealing.\n");
  pChar += rozofs_string_append(pChar,"// Required for spare file restoring to its nominal location.\n");
  COMMON_CONFIG_SHOW_STRING(export_hosts,"");
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_BOOL(spare_restore_enable,True);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// Spare file restoring : whether the service is active or not\n");
  COMMON_CONFIG_SHOW_BOOL(spare_restore_enable,True);
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_INT(spare_restore_loop_delay,240);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// Spare file restoring : how often the process runs  \n");
  COMMON_CONFIG_SHOW_INT(spare_restore_loop_delay,240);
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_INT(default_rebuild_reloop,4);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// Default rebuild reloop value \n");
  pChar += rozofs_string_append(pChar,"// Mainly used to help simulation\n");
  COMMON_CONFIG_SHOW_INT(default_rebuild_reloop,4);
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_INT(spare_restore_read_throughput,10);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// Spare file restoring : throughput limitation for reading and analyzing spare files in MB/s\n");
  pChar += rozofs_string_append(pChar,"// 0 means no limit\n");
  COMMON_CONFIG_SHOW_INT(spare_restore_read_throughput,10);
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_INT(storio_fidctx_ctx,256);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// Storio number of FID context in 1K unit\n");
  COMMON_CONFIG_SHOW_INT(storio_fidctx_ctx,256);
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_INT(spare_restore_spare_ctx,16);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// Spare file restoring : Number of spare file context in 1K unit\n");
  COMMON_CONFIG_SHOW_INT(spare_restore_spare_ctx,16);
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_INT(rdma_delay_ms,0);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// RDMA write dequeue delay: delay in ms before dequeueing a new request (for network with latency)\n");
  COMMON_CONFIG_SHOW_INT(rdma_delay_ms,0);
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_INT(rdma_delay_threshold,12);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// RDMA write dequeue delay: threshold when reached that prevents RDMA delay to be called\n");
  COMMON_CONFIG_SHOW_INT_OPT(rdma_delay_threshold,12,"0:64");
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_BOOL(mandatory_device_label,False);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// Whether RozoFS devices must mandatorily be identified by a valid label.\n");
  pChar += rozofs_string_append(pChar,"// Storages will not mount any device not having a valid RozoFS label.\n");
  COMMON_CONFIG_SHOW_BOOL(mandatory_device_label,False);
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  return pChar;
}
/*____________________________________________________________________________________________
**
** storage scope configuration parameters
**
*/
char * show_common_config_module_storage_short(char * pChar) {

  pChar += rozofs_string_append_effect(pChar,"#                                                            \n#     ", ROZOFS_COLOR_BLUE ROZOFS_COLOR_BOLD ROZOFS_COLOR_REVERSE);
  pChar += rozofs_string_append_effect(pChar,"    STORAGE SCOPE CONFIGURATION PARAMETERS        ", ROZOFS_COLOR_YELLOW ROZOFS_COLOR_BOLD ROZOFS_COLOR_REVERSE);
  pChar += rozofs_string_append_effect(pChar,"     \n#                                                            \n\n", ROZOFS_COLOR_BLUE ROZOFS_COLOR_BOLD ROZOFS_COLOR_REVERSE);


  COMMON_CONFIG_IS_DEFAULT_INT(nb_storaged_subthread,8);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Number of sub threads in the storaged\n");
    COMMON_CONFIG_SHOW_INT_OPT(nb_storaged_subthread,8,"2:16");
  }


  COMMON_CONFIG_IS_DEFAULT_INT(nb_disk_thread,4);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"/// Number of disk threads in the STORIO.\n");
    COMMON_CONFIG_SHOW_INT_OPT(nb_disk_thread,4,"2:64");
  }


  COMMON_CONFIG_IS_DEFAULT_INT(nb_write_rdma_threads,4);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"/// Number of RDMA write threads in the STORIO.\n");
    COMMON_CONFIG_SHOW_INT_OPT(nb_write_rdma_threads,4,"2:64");
  }


  COMMON_CONFIG_IS_DEFAULT_BOOL(rdma_write_thread_enable,False);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// assert that Boolean to activate the RDMA write threads.\n");
    COMMON_CONFIG_SHOW_BOOL(rdma_write_thread_enable,False);
  }


  COMMON_CONFIG_IS_DEFAULT_BOOL(crc32c_check,True);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Whether CRC32 MUST be checked by STORIO.\n");
    COMMON_CONFIG_SHOW_BOOL(crc32c_check,True);
  }


  COMMON_CONFIG_IS_DEFAULT_BOOL(crc32c_generate,True);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Whether CRC32 MUST be computed by STORIO.\n");
    COMMON_CONFIG_SHOW_BOOL(crc32c_generate,True);
  }


  COMMON_CONFIG_IS_DEFAULT_BOOL(crc32c_hw_forced,False);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Whether CRC32 MUST be absolutly hardware computed by STORIO.\n");
    COMMON_CONFIG_SHOW_BOOL(crc32c_hw_forced,False);
  }


  COMMON_CONFIG_IS_DEFAULT_BOOL(allow_disk_spin_down,False);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Whether STORIO device monitoring should avoid reading from \n");
    pChar += rozofs_string_append(pChar,"// devices when no access have occured for read or write. This\n");
    pChar += rozofs_string_append(pChar,"// enables disk spin down to occur.\n");
    COMMON_CONFIG_SHOW_BOOL(allow_disk_spin_down,False);
  }


  COMMON_CONFIG_IS_DEFAULT_INT(disk_usage_threshold,0);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Over which device usage threashold should the STORIO log the event. \n");
    COMMON_CONFIG_SHOW_INT_OPT(disk_usage_threshold,0,"0:100");
  }


  COMMON_CONFIG_IS_DEFAULT_INT(disk_read_threshold,0);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Over which device read delay threashold should the STORIO log the event. \n");
    COMMON_CONFIG_SHOW_INT(disk_read_threshold,0);
  }


  COMMON_CONFIG_IS_DEFAULT_INT(disk_write_threshold,0);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Over which device write delay threashold should the STORIO log the event. \n");
    COMMON_CONFIG_SHOW_INT(disk_write_threshold,0);
  }


  COMMON_CONFIG_IS_DEFAULT_INT(storio_buf_cnt,256);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Number of STORIO receive buffer.\n");
    COMMON_CONFIG_SHOW_INT_OPT(storio_buf_cnt,256,"32:1024");
  }


  COMMON_CONFIG_IS_DEFAULT_INT(recycle_truncate_blocks,0);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Number of block to which the chunk files should be truncated on storage \n");
    pChar += rozofs_string_append(pChar,"// node at the time it is recycled.\n");
    COMMON_CONFIG_SHOW_INT(recycle_truncate_blocks,0);
  }


  COMMON_CONFIG_IS_DEFAULT_STRING(storaged_start_script,"");
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Name of an executable file that the storaged should call at startup\n");
    COMMON_CONFIG_SHOW_STRING(storaged_start_script,"");
  }


  COMMON_CONFIG_IS_DEFAULT_BOOL(device_automount,False);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Whether the storage has to automount the devices\n");
    COMMON_CONFIG_SHOW_BOOL(device_automount,False);
  }


  COMMON_CONFIG_IS_DEFAULT_STRING(device_automount_path,"/srv/rozofs/storages");
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// automount path where the devices should be mounted\n");
    COMMON_CONFIG_SHOW_STRING(device_automount_path,"/srv/rozofs/storages");
  }


  COMMON_CONFIG_IS_DEFAULT_STRING(device_automount_option,"");
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Device mounting options\n");
    COMMON_CONFIG_SHOW_STRING(device_automount_option,"");
  }


  COMMON_CONFIG_IS_DEFAULT_STRING(storage_temporary_dir,"/tmp");
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Directory to use on the storage node to build temporary files.\n");
    pChar += rozofs_string_append(pChar,"// Used for instance by the rebuild process.\n");
    COMMON_CONFIG_SHOW_STRING(storage_temporary_dir,"/tmp");
  }


  COMMON_CONFIG_IS_DEFAULT_INT(device_self_healing_process,8);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// self healing : Paralellism factor for device self healing feature\n");
    pChar += rozofs_string_append(pChar,"// i.e the number of process to run rebuild in //\n");
    COMMON_CONFIG_SHOW_INT_OPT(device_self_healing_process,8,"1:64");
  }


  COMMON_CONFIG_IS_DEFAULT_INT(device_selfhealing_delay,15);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// self healing : Fault duration in minutes before device selfhealing starts\n");
    COMMON_CONFIG_SHOW_INT_OPT(device_selfhealing_delay,15,"0:10000");
  }


  COMMON_CONFIG_IS_DEFAULT_INT(device_selfhealing_read_throughput,40);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// self healing :  throughput limitation in MB/s per rebuild process in //\n");
    pChar += rozofs_string_append(pChar,"// for reading external projections. The writing on disk is only\n");
    pChar += rozofs_string_append(pChar,"// 1/2 of that in layout 0, 1/4 in layout 1...\n");
    pChar += rozofs_string_append(pChar,"// 0 means no limit\n");
    COMMON_CONFIG_SHOW_INT_OPT(device_selfhealing_read_throughput,40,"0:10000");
  }


  COMMON_CONFIG_IS_DEFAULT_ENUM(device_selfhealing_mode,"spareOnly");
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// self healing : possible modes\n");
    pChar += rozofs_string_append(pChar,"// spareOnly  only self repair on a spare disk\n");
    pChar += rozofs_string_append(pChar,"// relocate   also repair on remaining disks when no spare available\n");
    pChar += rozofs_string_append(pChar,"// resecure   repair on spare device when available, and then resecure files on\n");
    pChar += rozofs_string_append(pChar,"//            spare storages when no spare device is available\n");
    pChar += rozofs_string_append(pChar,"// none       No self healing is processed. Only manual rebuild is allowed.\n");
    COMMON_CONFIG_SHOW_ENUM(device_selfhealing_mode,"spareOnly","spareOnly,resecure,relocate,none");
  }


  COMMON_CONFIG_IS_DEFAULT_STRING(export_hosts,"");
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Export host names or IP addresses separated with / \n");
    pChar += rozofs_string_append(pChar,"// Required for selfhealing.\n");
    pChar += rozofs_string_append(pChar,"// Required for spare file restoring to its nominal location.\n");
    COMMON_CONFIG_SHOW_STRING(export_hosts,"");
  }


  COMMON_CONFIG_IS_DEFAULT_BOOL(spare_restore_enable,True);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Spare file restoring : whether the service is active or not\n");
    COMMON_CONFIG_SHOW_BOOL(spare_restore_enable,True);
  }


  COMMON_CONFIG_IS_DEFAULT_INT(spare_restore_loop_delay,240);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Spare file restoring : how often the process runs  \n");
    COMMON_CONFIG_SHOW_INT(spare_restore_loop_delay,240);
  }


  COMMON_CONFIG_IS_DEFAULT_INT(default_rebuild_reloop,4);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Default rebuild reloop value \n");
    pChar += rozofs_string_append(pChar,"// Mainly used to help simulation\n");
    COMMON_CONFIG_SHOW_INT(default_rebuild_reloop,4);
  }


  COMMON_CONFIG_IS_DEFAULT_INT(spare_restore_read_throughput,10);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Spare file restoring : throughput limitation for reading and analyzing spare files in MB/s\n");
    pChar += rozofs_string_append(pChar,"// 0 means no limit\n");
    COMMON_CONFIG_SHOW_INT(spare_restore_read_throughput,10);
  }


  COMMON_CONFIG_IS_DEFAULT_INT(storio_fidctx_ctx,256);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Storio number of FID context in 1K unit\n");
    COMMON_CONFIG_SHOW_INT(storio_fidctx_ctx,256);
  }


  COMMON_CONFIG_IS_DEFAULT_INT(spare_restore_spare_ctx,16);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Spare file restoring : Number of spare file context in 1K unit\n");
    COMMON_CONFIG_SHOW_INT(spare_restore_spare_ctx,16);
  }


  COMMON_CONFIG_IS_DEFAULT_INT(rdma_delay_ms,0);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// RDMA write dequeue delay: delay in ms before dequeueing a new request (for network with latency)\n");
    COMMON_CONFIG_SHOW_INT(rdma_delay_ms,0);
  }


  COMMON_CONFIG_IS_DEFAULT_INT(rdma_delay_threshold,12);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// RDMA write dequeue delay: threshold when reached that prevents RDMA delay to be called\n");
    COMMON_CONFIG_SHOW_INT_OPT(rdma_delay_threshold,12,"0:64");
  }


  COMMON_CONFIG_IS_DEFAULT_BOOL(mandatory_device_label,False);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Whether RozoFS devices must mandatorily be identified by a valid label.\n");
    pChar += rozofs_string_append(pChar,"// Storages will not mount any device not having a valid RozoFS label.\n");
    COMMON_CONFIG_SHOW_BOOL(mandatory_device_label,False);
  }
  return pChar;
}
/*____________________________________________________________________________________________
**
** storcli scope configuration parameters
**
*/
char * show_common_config_module_storcli(char * pChar) {

  pChar += rozofs_string_append_effect(pChar,"#                                                            \n#     ", ROZOFS_COLOR_BLUE ROZOFS_COLOR_BOLD ROZOFS_COLOR_REVERSE);
  pChar += rozofs_string_append_effect(pChar,"    STORCLI SCOPE CONFIGURATION PARAMETERS        ", ROZOFS_COLOR_YELLOW ROZOFS_COLOR_BOLD ROZOFS_COLOR_REVERSE);
  pChar += rozofs_string_append_effect(pChar,"     \n#                                                            \n\n", ROZOFS_COLOR_BLUE ROZOFS_COLOR_BOLD ROZOFS_COLOR_REVERSE);

  COMMON_CONFIG_IS_DEFAULT_BOOL(rdma_enable,False);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// When that flag is asserted, the storcli uses RDMA when storio supports it\n");
  COMMON_CONFIG_SHOW_BOOL(rdma_enable,False);
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_BOOL(rdma_full,False);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// When that flag is asserted, the storcli uses RDMA for data transfer and RPC messages\n");
  COMMON_CONFIG_SHOW_BOOL(rdma_full,False);
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_INT(min_rmda_size_KB,64);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// Minimum read/write size in KB to trigger RDMA transfer\n");
  COMMON_CONFIG_SHOW_INT(min_rmda_size_KB,64);
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_INT(mojette_thread_count,4);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// number of Mojette threads\n");
  COMMON_CONFIG_SHOW_INT_OPT(mojette_thread_count,4,"1:4");
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  return pChar;
}
/*____________________________________________________________________________________________
**
** storcli scope configuration parameters
**
*/
char * show_common_config_module_storcli_short(char * pChar) {

  pChar += rozofs_string_append_effect(pChar,"#                                                            \n#     ", ROZOFS_COLOR_BLUE ROZOFS_COLOR_BOLD ROZOFS_COLOR_REVERSE);
  pChar += rozofs_string_append_effect(pChar,"    STORCLI SCOPE CONFIGURATION PARAMETERS        ", ROZOFS_COLOR_YELLOW ROZOFS_COLOR_BOLD ROZOFS_COLOR_REVERSE);
  pChar += rozofs_string_append_effect(pChar,"     \n#                                                            \n\n", ROZOFS_COLOR_BLUE ROZOFS_COLOR_BOLD ROZOFS_COLOR_REVERSE);


  COMMON_CONFIG_IS_DEFAULT_BOOL(rdma_enable,False);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// When that flag is asserted, the storcli uses RDMA when storio supports it\n");
    COMMON_CONFIG_SHOW_BOOL(rdma_enable,False);
  }


  COMMON_CONFIG_IS_DEFAULT_BOOL(rdma_full,False);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// When that flag is asserted, the storcli uses RDMA for data transfer and RPC messages\n");
    COMMON_CONFIG_SHOW_BOOL(rdma_full,False);
  }


  COMMON_CONFIG_IS_DEFAULT_INT(min_rmda_size_KB,64);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Minimum read/write size in KB to trigger RDMA transfer\n");
    COMMON_CONFIG_SHOW_INT(min_rmda_size_KB,64);
  }


  COMMON_CONFIG_IS_DEFAULT_INT(mojette_thread_count,4);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// number of Mojette threads\n");
    COMMON_CONFIG_SHOW_INT_OPT(mojette_thread_count,4,"1:4");
  }
  return pChar;
}
/*____________________________________________________________________________________________
**
** expbt scope configuration parameters
**
*/
char * show_common_config_module_expbt(char * pChar) {

  pChar += rozofs_string_append_effect(pChar,"#                                                            \n#     ", ROZOFS_COLOR_BLUE ROZOFS_COLOR_BOLD ROZOFS_COLOR_REVERSE);
  pChar += rozofs_string_append_effect(pChar,"    EXPBT SCOPE CONFIGURATION PARAMETERS          ", ROZOFS_COLOR_YELLOW ROZOFS_COLOR_BOLD ROZOFS_COLOR_REVERSE);
  pChar += rozofs_string_append_effect(pChar,"     \n#                                                            \n\n", ROZOFS_COLOR_BLUE ROZOFS_COLOR_BOLD ROZOFS_COLOR_REVERSE);

  COMMON_CONFIG_IS_DEFAULT_BOOL(expbt_active,False);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// Whether export file tracking reader for rozofsmount batch is enabled\n");
  COMMON_CONFIG_SHOW_BOOL(expbt_active,False);
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_INT(nb_expbt_thread,4);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"/// Number of file tracking reader threads.\n");
  COMMON_CONFIG_SHOW_INT_OPT(nb_expbt_thread,4,"2:32");
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_INT(expbt_buf_cnt,32);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// Number of STORIO receive buffer.\n");
  COMMON_CONFIG_SHOW_INT_OPT(expbt_buf_cnt,32,"8:128");
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  return pChar;
}
/*____________________________________________________________________________________________
**
** expbt scope configuration parameters
**
*/
char * show_common_config_module_expbt_short(char * pChar) {

  pChar += rozofs_string_append_effect(pChar,"#                                                            \n#     ", ROZOFS_COLOR_BLUE ROZOFS_COLOR_BOLD ROZOFS_COLOR_REVERSE);
  pChar += rozofs_string_append_effect(pChar,"    EXPBT SCOPE CONFIGURATION PARAMETERS          ", ROZOFS_COLOR_YELLOW ROZOFS_COLOR_BOLD ROZOFS_COLOR_REVERSE);
  pChar += rozofs_string_append_effect(pChar,"     \n#                                                            \n\n", ROZOFS_COLOR_BLUE ROZOFS_COLOR_BOLD ROZOFS_COLOR_REVERSE);


  COMMON_CONFIG_IS_DEFAULT_BOOL(expbt_active,False);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Whether export file tracking reader for rozofsmount batch is enabled\n");
    COMMON_CONFIG_SHOW_BOOL(expbt_active,False);
  }


  COMMON_CONFIG_IS_DEFAULT_INT(nb_expbt_thread,4);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"/// Number of file tracking reader threads.\n");
    COMMON_CONFIG_SHOW_INT_OPT(nb_expbt_thread,4,"2:32");
  }


  COMMON_CONFIG_IS_DEFAULT_INT(expbt_buf_cnt,32);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Number of STORIO receive buffer.\n");
    COMMON_CONFIG_SHOW_INT_OPT(expbt_buf_cnt,32,"8:128");
  }
  return pChar;
}
/*____________________________________________________________________________________________
**
** batch scope configuration parameters
**
*/
char * show_common_config_module_batch(char * pChar) {

  pChar += rozofs_string_append_effect(pChar,"#                                                            \n#     ", ROZOFS_COLOR_BLUE ROZOFS_COLOR_BOLD ROZOFS_COLOR_REVERSE);
  pChar += rozofs_string_append_effect(pChar,"    BATCH SCOPE CONFIGURATION PARAMETERS          ", ROZOFS_COLOR_YELLOW ROZOFS_COLOR_BOLD ROZOFS_COLOR_REVERSE);
  pChar += rozofs_string_append_effect(pChar,"     \n#                                                            \n\n", ROZOFS_COLOR_BLUE ROZOFS_COLOR_BOLD ROZOFS_COLOR_REVERSE);

  COMMON_CONFIG_IS_DEFAULT_INT(dirent_cache_size,250000);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// Max number of entries in the dirent and root bitmap caches\n");
  COMMON_CONFIG_SHOW_INT_OPT(dirent_cache_size,250000,"2:500000");
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_INT(dirent_garbage_delay,5);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// retention delay before memory release for dirent and bitmap entries in cache (seconds)\n");
  COMMON_CONFIG_SHOW_INT_OPT(dirent_garbage_delay,5,"1:60");
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_INT(trk_cache_size,2048);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// Max number of entries in tracking file cache\n");
  COMMON_CONFIG_SHOW_INT_OPT(trk_cache_size,2048,"32:8192");
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_INT(trk_garbage_delay,5);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// retention delay before memory release in tracking file cache (seconds)\n");
  COMMON_CONFIG_SHOW_INT_OPT(trk_garbage_delay,5,"1:60");
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);

  COMMON_CONFIG_IS_DEFAULT_INT(trk_expiration_delay,120);
  if (isDefaultValue==0) pChar += rozofs_string_set_bold(pChar);
  pChar += rozofs_string_append(pChar,"// expiration delay of an entry of the tracking file cache (seconds)\n");
  COMMON_CONFIG_SHOW_INT_OPT(trk_expiration_delay,120,"4:600");
  if (isDefaultValue==0) pChar += rozofs_string_set_default(pChar);
  return pChar;
}
/*____________________________________________________________________________________________
**
** batch scope configuration parameters
**
*/
char * show_common_config_module_batch_short(char * pChar) {

  pChar += rozofs_string_append_effect(pChar,"#                                                            \n#     ", ROZOFS_COLOR_BLUE ROZOFS_COLOR_BOLD ROZOFS_COLOR_REVERSE);
  pChar += rozofs_string_append_effect(pChar,"    BATCH SCOPE CONFIGURATION PARAMETERS          ", ROZOFS_COLOR_YELLOW ROZOFS_COLOR_BOLD ROZOFS_COLOR_REVERSE);
  pChar += rozofs_string_append_effect(pChar,"     \n#                                                            \n\n", ROZOFS_COLOR_BLUE ROZOFS_COLOR_BOLD ROZOFS_COLOR_REVERSE);


  COMMON_CONFIG_IS_DEFAULT_INT(dirent_cache_size,250000);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Max number of entries in the dirent and root bitmap caches\n");
    COMMON_CONFIG_SHOW_INT_OPT(dirent_cache_size,250000,"2:500000");
  }


  COMMON_CONFIG_IS_DEFAULT_INT(dirent_garbage_delay,5);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// retention delay before memory release for dirent and bitmap entries in cache (seconds)\n");
    COMMON_CONFIG_SHOW_INT_OPT(dirent_garbage_delay,5,"1:60");
  }


  COMMON_CONFIG_IS_DEFAULT_INT(trk_cache_size,2048);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Max number of entries in tracking file cache\n");
    COMMON_CONFIG_SHOW_INT_OPT(trk_cache_size,2048,"32:8192");
  }


  COMMON_CONFIG_IS_DEFAULT_INT(trk_garbage_delay,5);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// retention delay before memory release in tracking file cache (seconds)\n");
    COMMON_CONFIG_SHOW_INT_OPT(trk_garbage_delay,5,"1:60");
  }


  COMMON_CONFIG_IS_DEFAULT_INT(trk_expiration_delay,120);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// expiration delay of an entry of the tracking file cache (seconds)\n");
    COMMON_CONFIG_SHOW_INT_OPT(trk_expiration_delay,120,"4:600");
  }
  return pChar;
}
/*____________________________________________________________________________________________
**
** global scope configuration parameters
**
*/
char * save_common_config_module_global(char * pChar) {

  pChar += rozofs_string_append(pChar,"#____________________________________________________________\n");
  pChar += rozofs_string_append(pChar,"# ");
  pChar += rozofs_string_append(pChar,"global");
  pChar += rozofs_string_append(pChar," scope configuration parameters\n");
  pChar += rozofs_string_append(pChar,"#____________________________________________________________\n\n");

  COMMON_CONFIG_IS_DEFAULT_INT(nb_core_file,1);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Number of core files that the system is allowed to keep for all the modules of this server.\n");
    pChar += rozofs_string_append(pChar,"// Older core files are kept while newest are removed.	\n");
    COMMON_CONFIG_SHOW_INT_OPT(nb_core_file,1,"0:8");
  }

  COMMON_CONFIG_IS_DEFAULT_STRING(core_file_directory,"");
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Directory where the core files are stored.\n");
    COMMON_CONFIG_SHOW_STRING(core_file_directory,"");
  }

  COMMON_CONFIG_IS_DEFAULT_BOOL(numa_aware,False);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Enables to take into account the NUMA architecture of the board in \n");
    pChar += rozofs_string_append(pChar,"// order to collocate some RozoFS modules on the same node for memory\n");
    pChar += rozofs_string_append(pChar,"// access efficiency.\n");
    COMMON_CONFIG_SHOW_BOOL(numa_aware,False);
  }

  COMMON_CONFIG_IS_DEFAULT_INT(adaptor_numa_node,-1);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Ethernet Adaptor numa node (-1 not significant)\n");
    COMMON_CONFIG_SHOW_INT(adaptor_numa_node,-1);
  }

  COMMON_CONFIG_IS_DEFAULT_ENUM(processor_model,"INTEL");
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// processor model:\n");
    pChar += rozofs_string_append(pChar,"// EPYC: all AMD CPUs \n");
    pChar += rozofs_string_append(pChar,"// INTEL:   covers E5 & skylake families\n");
    COMMON_CONFIG_SHOW_ENUM(processor_model,"INTEL","EPYC,INTEL");
  }

  COMMON_CONFIG_IS_DEFAULT_INT(storio_slice_number,1024);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Number of slices in the STORIO.\n");
    COMMON_CONFIG_SHOW_INT_OPT(storio_slice_number,1024,"8:(32*1024)");
  }

  COMMON_CONFIG_IS_DEFAULT_INT(file_distribution_rule,0);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// File distribution mode upon cluster, storages and devices. Check rozofs.conf manual.\n");
    pChar += rozofs_string_append(pChar,"// 0         = Cluster size balancing                   + device size balancing\n");
    pChar += rozofs_string_append(pChar,"// 1,2,3     = Cluster strict round robin               + device write spreading\n");
    pChar += rozofs_string_append(pChar,"// 4         = Cluster strict round robin               + device read spreading\n");
    pChar += rozofs_string_append(pChar,"// 5         = Cluster weighted round robin (nb SID)    + device write spreading\n");
    pChar += rozofs_string_append(pChar,"// 6         = Cluster weighted round robin (nb SID)    + device read spreading\n");
    pChar += rozofs_string_append(pChar,"// 7         = Cluster weighted round robin (free size) + device write spreading\n");
    pChar += rozofs_string_append(pChar,"// 6         = Cluster weighted round robin (free size) + device read spreading\n");
    COMMON_CONFIG_SHOW_INT_OPT(file_distribution_rule,0,"0:100");
  }

  COMMON_CONFIG_IS_DEFAULT_INT(storio_dscp,46);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// DSCP for exchanges from/to the STORIO.\n");
    COMMON_CONFIG_SHOW_INT_OPT(storio_dscp,46,"0:46");
  }

  COMMON_CONFIG_IS_DEFAULT_INT(export_dscp,34);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// DSCP for exchanges from/to the EXPORTD.\n");
    COMMON_CONFIG_SHOW_INT_OPT(export_dscp,34,"0:34");
  }

  COMMON_CONFIG_IS_DEFAULT_BOOL(standalone,False);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// When that flag is asserted, RozoFS operates in standalone mode only.\n");
    COMMON_CONFIG_SHOW_BOOL(standalone,False);
  }

  COMMON_CONFIG_IS_DEFAULT_ENUM(diagnostic_mode,"both");
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// rozodiag mode\n");
    pChar += rozofs_string_append(pChar,"// server     Each RozoFS module listen for rozodiag command on its dedicated server port\n");
    pChar += rozofs_string_append(pChar,"// client     Each RozoFS module is client of a local rozodiag server that relays rozodiag commands\n");
    pChar += rozofs_string_append(pChar,"// both       Each RozoFS module is client as well as server\n");
    pChar += rozofs_string_append(pChar,"//    \n");
    COMMON_CONFIG_SHOW_ENUM(diagnostic_mode,"both","both,server,client");
  }
  return pChar;
}
/*____________________________________________________________________________________________
**
** export scope configuration parameters
**
*/
char * save_common_config_module_export(char * pChar) {

  pChar += rozofs_string_append(pChar,"#____________________________________________________________\n");
  pChar += rozofs_string_append(pChar,"# ");
  pChar += rozofs_string_append(pChar,"export");
  pChar += rozofs_string_append(pChar," scope configuration parameters\n");
  pChar += rozofs_string_append(pChar,"#____________________________________________________________\n\n");

  COMMON_CONFIG_IS_DEFAULT_INT(trashed_file_per_run,1000);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Max number of file that the exportd can remove from storages in a run.\n");
    pChar += rozofs_string_append(pChar,"// A new run occurs every 2 seconds.\n");
    COMMON_CONFIG_SHOW_INT(trashed_file_per_run,1000);
  }

  COMMON_CONFIG_IS_DEFAULT_INT(trash_high_threshold,1000);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// High trash water mark when FID recycling is activated.\n");
    pChar += rozofs_string_append(pChar,"// When the trash has already this number of files, files are no more\n");
    pChar += rozofs_string_append(pChar,"// deleted but recycled.\n");
    COMMON_CONFIG_SHOW_INT_OPT(trash_high_threshold,1000,"0:1000000");
  }

  COMMON_CONFIG_IS_DEFAULT_BOOL(fid_recycle,False);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Whether FID recycling feature is activated.\n");
    COMMON_CONFIG_SHOW_BOOL(fid_recycle,False);
  }

  COMMON_CONFIG_IS_DEFAULT_INT(export_buf_cnt,128);
  if (isDefaultValue==0) {
    COMMON_CONFIG_SHOW_INT_OPT(export_buf_cnt,128,"32:1024");
  }

  COMMON_CONFIG_IS_DEFAULT_BOOL(export_attr_thread,True);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// To activate export writebehind attributes thread.\n");
    COMMON_CONFIG_SHOW_BOOL(export_attr_thread,True);
  }

  COMMON_CONFIG_IS_DEFAULT_BOOL(export_versioning,False);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Support of deleted directory/file versioning.\n");
    COMMON_CONFIG_SHOW_BOOL(export_versioning,False);
  }

  COMMON_CONFIG_IS_DEFAULT_INT(alloc_estimated_mb,1);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Number of MB to account a file for during file distribution phase\n");
    COMMON_CONFIG_SHOW_INT(alloc_estimated_mb,1);
  }

  COMMON_CONFIG_IS_DEFAULT_INT(client_flock_timeout,30);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Delay from which a rozofsmoun client is declared disconnected and its \n");
    pChar += rozofs_string_append(pChar,"// file locks are automatically removed\n");
    COMMON_CONFIG_SHOW_INT_OPT(client_flock_timeout,30,"15:600");
  }

  COMMON_CONFIG_IS_DEFAULT_INT(mproto_timeout,10);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Time out between export and storage for remove and stat\n");
    COMMON_CONFIG_SHOW_INT_OPT(mproto_timeout,10,"1:60");
  }

  COMMON_CONFIG_IS_DEFAULT_STRING(export_temporary_dir,"/tmp");
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Directory to use on the export to build temporary files.\n");
    pChar += rozofs_string_append(pChar,"// Used for instance to build list of files to rebuild.\n");
    COMMON_CONFIG_SHOW_STRING(export_temporary_dir,"/tmp");
  }

  COMMON_CONFIG_IS_DEFAULT_BOOL(mkdir_ok_instead_of_eexist,False);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// To activate workaround that make mkdir respond OK instead of EEXIST\n");
    pChar += rozofs_string_append(pChar,"// when the directory is already created \n");
    COMMON_CONFIG_SHOW_BOOL(mkdir_ok_instead_of_eexist,False);
  }

  COMMON_CONFIG_IS_DEFAULT_BOOL(mknod_ok_instead_of_eexist,False);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// To activate workaround that make mknod respond OK instead of EEXIST\n");
    pChar += rozofs_string_append(pChar,"// when the file is already created  \n");
    COMMON_CONFIG_SHOW_BOOL(mknod_ok_instead_of_eexist,False);
  }

  COMMON_CONFIG_IS_DEFAULT_BOOL(disable_sync_attributes,False);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// To disable synchronous write of attributes when set to True\n");
    COMMON_CONFIG_SHOW_BOOL(disable_sync_attributes,False);
  }

  COMMON_CONFIG_IS_DEFAULT_INT(deletion_delay,30);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Minimum delay between the deletion request and the effective projections deletion\n");
    COMMON_CONFIG_SHOW_INT(deletion_delay,30);
  }

  COMMON_CONFIG_IS_DEFAULT_INT(min_metadata_inodes,262144);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Minimum number of inodes that must be available on metadata device to allow a mknod/mkdir operation\n");
    COMMON_CONFIG_SHOW_INT(min_metadata_inodes,262144);
  }

  COMMON_CONFIG_IS_DEFAULT_INT(min_metadata_MB,2048);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Minimum available size in MB that must be available on metadata device to allow a mknod/mkdir operation\n");
    COMMON_CONFIG_SHOW_INT(min_metadata_MB,2048);
  }

  COMMON_CONFIG_IS_DEFAULT_INT(nb_trash_thread,2);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Number of trash threads that work in parallel\n");
    COMMON_CONFIG_SHOW_INT_OPT(nb_trash_thread,2,"1:8");
  }

  COMMON_CONFIG_IS_DEFAULT_INT(nb_thin_thread,2);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Number of thin provisioning threads that work in parallel\n");
    COMMON_CONFIG_SHOW_INT_OPT(nb_thin_thread,2,"1:4");
  }

  COMMON_CONFIG_IS_DEFAULT_INT(thin_scan_file_per_run,1000);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Max number of files that the exportd can submit to storages to get the number of blocks (thin provisioning) in a run.\n");
    pChar += rozofs_string_append(pChar,"// A new run occurs every 2 seconds.\n");
    COMMON_CONFIG_SHOW_INT(thin_scan_file_per_run,1000);
  }

  COMMON_CONFIG_IS_DEFAULT_INT(thin_lv1_hash_tb_size,10);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Thin provisioning Level 1 hash table size in power of 2 (changing this parameter will take effect on the next export restart) \n");
    COMMON_CONFIG_SHOW_INT_OPT(thin_lv1_hash_tb_size,10,"6:128");
  }

  COMMON_CONFIG_IS_DEFAULT_INT(expthin_guard_delay_sec,10);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Guard delay in seconds between two file scanning of a file that belongs to an exportd configured for thin provisioning\n");
    COMMON_CONFIG_SHOW_INT_OPT(expthin_guard_delay_sec,10,"1:600");
  }

  COMMON_CONFIG_IS_DEFAULT_INT(expdir_guard_delay_sec,10);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Guard delay associated with directory re-write used for tracking children changes within a directory \n");
    COMMON_CONFIG_SHOW_INT_OPT(expdir_guard_delay_sec,10,"1:7200");
  }

  COMMON_CONFIG_IS_DEFAULT_INT(level2_cache_max_entries_kb,512);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Maximum number of entries that the export level 2 cache can contain (unit is KB) \n");
    COMMON_CONFIG_SHOW_INT_OPT(level2_cache_max_entries_kb,512,"1:4096");
  }

  COMMON_CONFIG_IS_DEFAULT_BOOL(persistent_file_locks,False);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Whether file locks must be persistent on exportd restart/switchover or not\n");
    COMMON_CONFIG_SHOW_BOOL(persistent_file_locks,False);
  }

  COMMON_CONFIG_IS_DEFAULT_INT(minimum_free_size_percent,4);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Minimum % of free space in a volume.\n");
    pChar += rozofs_string_append(pChar,"// When the free space of a volume reaches this value, file creation requests\n");
    pChar += rozofs_string_append(pChar,"// receive back ENOSPC in order to try to avoid later write errors.\n");
    pChar += rozofs_string_append(pChar,"// A value of 0 means there is no limit on the volume.\n");
    pChar += rozofs_string_append(pChar,"// A value of 100 forbids every file creation.\n");
    COMMON_CONFIG_SHOW_INT_OPT(minimum_free_size_percent,4,"0:100");
  }
  return pChar;
}
/*____________________________________________________________________________________________
**
** client scope configuration parameters
**
*/
char * save_common_config_module_client(char * pChar) {

  pChar += rozofs_string_append(pChar,"#____________________________________________________________\n");
  pChar += rozofs_string_append(pChar,"# ");
  pChar += rozofs_string_append(pChar,"client");
  pChar += rozofs_string_append(pChar," scope configuration parameters\n");
  pChar += rozofs_string_append(pChar,"#____________________________________________________________\n\n");

  COMMON_CONFIG_IS_DEFAULT_BOOL(wr_ack_on_inverse,False);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Whether STORCLI acknowleges write request on inverse or forward STORIO responses.\n");
    COMMON_CONFIG_SHOW_BOOL(wr_ack_on_inverse,False);
  }

  COMMON_CONFIG_IS_DEFAULT_BOOL(wr_pending_anticipated,False);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// To indicate if we can respond before write_pending reaches 0.\n");
    COMMON_CONFIG_SHOW_BOOL(wr_pending_anticipated,False);
  }

  COMMON_CONFIG_IS_DEFAULT_INT(rozofsmount_fuse_reply_thread,0);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// To activate rozofsmount reply fuse threads.\n");
    COMMON_CONFIG_SHOW_INT_OPT(rozofsmount_fuse_reply_thread,0,"0:4");
  }

  COMMON_CONFIG_IS_DEFAULT_BOOL(client_fast_reconnect,False);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// To activate fast reconnect from client to exportd\n");
    COMMON_CONFIG_SHOW_BOOL(client_fast_reconnect,False);
  }

  COMMON_CONFIG_IS_DEFAULT_INT(archive_file_delay,10);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// delay is minutes after which a file is considered as an archived file (unit is minute)\n");
    COMMON_CONFIG_SHOW_INT_OPT(archive_file_delay,10,"0:3600");
  }

  COMMON_CONFIG_IS_DEFAULT_INT(archive_file_dentry_timeout,30);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// dentry cache timeout for archive file type (unit is second)\n");
    COMMON_CONFIG_SHOW_INT_OPT(archive_file_dentry_timeout,30,"0:300");
  }

  COMMON_CONFIG_IS_DEFAULT_INT(archive_file_attr_timeout,30);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// attribute cache timeout for archive file type (unit is second)\n");
    COMMON_CONFIG_SHOW_INT_OPT(archive_file_attr_timeout,30,"0:300");
  }

  COMMON_CONFIG_IS_DEFAULT_BOOL(client_xattr_cache,False);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// When that flag is asserted, the rozofsmount client can cache the extended attributes\n");
    COMMON_CONFIG_SHOW_BOOL(client_xattr_cache,False);
  }

  COMMON_CONFIG_IS_DEFAULT_BOOL(async_setattr,False);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// When that flag is asserted, the rozofsmount client performs setattr in asynchronous mode\n");
    COMMON_CONFIG_SHOW_BOOL(async_setattr,False);
  }

  COMMON_CONFIG_IS_DEFAULT_INT(statfs_period,10);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// statfs period in seconds. minimum is 0.\n");
    COMMON_CONFIG_SHOW_INT(statfs_period,10);
  }

  COMMON_CONFIG_IS_DEFAULT_INT(reply_thread_count,2);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// number of Fuse threads\n");
    COMMON_CONFIG_SHOW_INT_OPT(reply_thread_count,2,"1:8");
  }

  COMMON_CONFIG_IS_DEFAULT_BOOL(bufread_bypass,False);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Buffer read by-pass\n");
    COMMON_CONFIG_SHOW_BOOL(bufread_bypass,False);
  }

  COMMON_CONFIG_IS_DEFAULT_BOOL(storcli_read_parallel,False);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// When that flag is asserted any storcli can be selected for reading.\n");
    COMMON_CONFIG_SHOW_BOOL(storcli_read_parallel,False);
  }
  return pChar;
}
/*____________________________________________________________________________________________
**
** storage scope configuration parameters
**
*/
char * save_common_config_module_storage(char * pChar) {

  pChar += rozofs_string_append(pChar,"#____________________________________________________________\n");
  pChar += rozofs_string_append(pChar,"# ");
  pChar += rozofs_string_append(pChar,"storage");
  pChar += rozofs_string_append(pChar," scope configuration parameters\n");
  pChar += rozofs_string_append(pChar,"#____________________________________________________________\n\n");

  COMMON_CONFIG_IS_DEFAULT_INT(nb_storaged_subthread,8);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Number of sub threads in the storaged\n");
    COMMON_CONFIG_SHOW_INT_OPT(nb_storaged_subthread,8,"2:16");
  }

  COMMON_CONFIG_IS_DEFAULT_INT(nb_disk_thread,4);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"/// Number of disk threads in the STORIO.\n");
    COMMON_CONFIG_SHOW_INT_OPT(nb_disk_thread,4,"2:64");
  }

  COMMON_CONFIG_IS_DEFAULT_INT(nb_write_rdma_threads,4);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"/// Number of RDMA write threads in the STORIO.\n");
    COMMON_CONFIG_SHOW_INT_OPT(nb_write_rdma_threads,4,"2:64");
  }

  COMMON_CONFIG_IS_DEFAULT_BOOL(rdma_write_thread_enable,False);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// assert that Boolean to activate the RDMA write threads.\n");
    COMMON_CONFIG_SHOW_BOOL(rdma_write_thread_enable,False);
  }

  COMMON_CONFIG_IS_DEFAULT_BOOL(crc32c_check,True);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Whether CRC32 MUST be checked by STORIO.\n");
    COMMON_CONFIG_SHOW_BOOL(crc32c_check,True);
  }

  COMMON_CONFIG_IS_DEFAULT_BOOL(crc32c_generate,True);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Whether CRC32 MUST be computed by STORIO.\n");
    COMMON_CONFIG_SHOW_BOOL(crc32c_generate,True);
  }

  COMMON_CONFIG_IS_DEFAULT_BOOL(crc32c_hw_forced,False);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Whether CRC32 MUST be absolutly hardware computed by STORIO.\n");
    COMMON_CONFIG_SHOW_BOOL(crc32c_hw_forced,False);
  }

  COMMON_CONFIG_IS_DEFAULT_BOOL(allow_disk_spin_down,False);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Whether STORIO device monitoring should avoid reading from \n");
    pChar += rozofs_string_append(pChar,"// devices when no access have occured for read or write. This\n");
    pChar += rozofs_string_append(pChar,"// enables disk spin down to occur.\n");
    COMMON_CONFIG_SHOW_BOOL(allow_disk_spin_down,False);
  }

  COMMON_CONFIG_IS_DEFAULT_INT(disk_usage_threshold,0);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Over which device usage threashold should the STORIO log the event. \n");
    COMMON_CONFIG_SHOW_INT_OPT(disk_usage_threshold,0,"0:100");
  }

  COMMON_CONFIG_IS_DEFAULT_INT(disk_read_threshold,0);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Over which device read delay threashold should the STORIO log the event. \n");
    COMMON_CONFIG_SHOW_INT(disk_read_threshold,0);
  }

  COMMON_CONFIG_IS_DEFAULT_INT(disk_write_threshold,0);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Over which device write delay threashold should the STORIO log the event. \n");
    COMMON_CONFIG_SHOW_INT(disk_write_threshold,0);
  }

  COMMON_CONFIG_IS_DEFAULT_INT(storio_buf_cnt,256);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Number of STORIO receive buffer.\n");
    COMMON_CONFIG_SHOW_INT_OPT(storio_buf_cnt,256,"32:1024");
  }

  COMMON_CONFIG_IS_DEFAULT_INT(recycle_truncate_blocks,0);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Number of block to which the chunk files should be truncated on storage \n");
    pChar += rozofs_string_append(pChar,"// node at the time it is recycled.\n");
    COMMON_CONFIG_SHOW_INT(recycle_truncate_blocks,0);
  }

  COMMON_CONFIG_IS_DEFAULT_STRING(storaged_start_script,"");
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Name of an executable file that the storaged should call at startup\n");
    COMMON_CONFIG_SHOW_STRING(storaged_start_script,"");
  }

  COMMON_CONFIG_IS_DEFAULT_BOOL(device_automount,False);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Whether the storage has to automount the devices\n");
    COMMON_CONFIG_SHOW_BOOL(device_automount,False);
  }

  COMMON_CONFIG_IS_DEFAULT_STRING(device_automount_path,"/srv/rozofs/storages");
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// automount path where the devices should be mounted\n");
    COMMON_CONFIG_SHOW_STRING(device_automount_path,"/srv/rozofs/storages");
  }

  COMMON_CONFIG_IS_DEFAULT_STRING(device_automount_option,"");
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Device mounting options\n");
    COMMON_CONFIG_SHOW_STRING(device_automount_option,"");
  }

  COMMON_CONFIG_IS_DEFAULT_STRING(storage_temporary_dir,"/tmp");
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Directory to use on the storage node to build temporary files.\n");
    pChar += rozofs_string_append(pChar,"// Used for instance by the rebuild process.\n");
    COMMON_CONFIG_SHOW_STRING(storage_temporary_dir,"/tmp");
  }

  COMMON_CONFIG_IS_DEFAULT_INT(device_self_healing_process,8);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// self healing : Paralellism factor for device self healing feature\n");
    pChar += rozofs_string_append(pChar,"// i.e the number of process to run rebuild in //\n");
    COMMON_CONFIG_SHOW_INT_OPT(device_self_healing_process,8,"1:64");
  }

  COMMON_CONFIG_IS_DEFAULT_INT(device_selfhealing_delay,15);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// self healing : Fault duration in minutes before device selfhealing starts\n");
    COMMON_CONFIG_SHOW_INT_OPT(device_selfhealing_delay,15,"0:10000");
  }

  COMMON_CONFIG_IS_DEFAULT_INT(device_selfhealing_read_throughput,40);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// self healing :  throughput limitation in MB/s per rebuild process in //\n");
    pChar += rozofs_string_append(pChar,"// for reading external projections. The writing on disk is only\n");
    pChar += rozofs_string_append(pChar,"// 1/2 of that in layout 0, 1/4 in layout 1...\n");
    pChar += rozofs_string_append(pChar,"// 0 means no limit\n");
    COMMON_CONFIG_SHOW_INT_OPT(device_selfhealing_read_throughput,40,"0:10000");
  }

  COMMON_CONFIG_IS_DEFAULT_ENUM(device_selfhealing_mode,"spareOnly");
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// self healing : possible modes\n");
    pChar += rozofs_string_append(pChar,"// spareOnly  only self repair on a spare disk\n");
    pChar += rozofs_string_append(pChar,"// relocate   also repair on remaining disks when no spare available\n");
    pChar += rozofs_string_append(pChar,"// resecure   repair on spare device when available, and then resecure files on\n");
    pChar += rozofs_string_append(pChar,"//            spare storages when no spare device is available\n");
    pChar += rozofs_string_append(pChar,"// none       No self healing is processed. Only manual rebuild is allowed.\n");
    COMMON_CONFIG_SHOW_ENUM(device_selfhealing_mode,"spareOnly","spareOnly,resecure,relocate,none");
  }

  COMMON_CONFIG_IS_DEFAULT_STRING(export_hosts,"");
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Export host names or IP addresses separated with / \n");
    pChar += rozofs_string_append(pChar,"// Required for selfhealing.\n");
    pChar += rozofs_string_append(pChar,"// Required for spare file restoring to its nominal location.\n");
    COMMON_CONFIG_SHOW_STRING(export_hosts,"");
  }

  COMMON_CONFIG_IS_DEFAULT_BOOL(spare_restore_enable,True);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Spare file restoring : whether the service is active or not\n");
    COMMON_CONFIG_SHOW_BOOL(spare_restore_enable,True);
  }

  COMMON_CONFIG_IS_DEFAULT_INT(spare_restore_loop_delay,240);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Spare file restoring : how often the process runs  \n");
    COMMON_CONFIG_SHOW_INT(spare_restore_loop_delay,240);
  }

  COMMON_CONFIG_IS_DEFAULT_INT(default_rebuild_reloop,4);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Default rebuild reloop value \n");
    pChar += rozofs_string_append(pChar,"// Mainly used to help simulation\n");
    COMMON_CONFIG_SHOW_INT(default_rebuild_reloop,4);
  }

  COMMON_CONFIG_IS_DEFAULT_INT(spare_restore_read_throughput,10);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Spare file restoring : throughput limitation for reading and analyzing spare files in MB/s\n");
    pChar += rozofs_string_append(pChar,"// 0 means no limit\n");
    COMMON_CONFIG_SHOW_INT(spare_restore_read_throughput,10);
  }

  COMMON_CONFIG_IS_DEFAULT_INT(storio_fidctx_ctx,256);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Storio number of FID context in 1K unit\n");
    COMMON_CONFIG_SHOW_INT(storio_fidctx_ctx,256);
  }

  COMMON_CONFIG_IS_DEFAULT_INT(spare_restore_spare_ctx,16);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Spare file restoring : Number of spare file context in 1K unit\n");
    COMMON_CONFIG_SHOW_INT(spare_restore_spare_ctx,16);
  }

  COMMON_CONFIG_IS_DEFAULT_INT(rdma_delay_ms,0);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// RDMA write dequeue delay: delay in ms before dequeueing a new request (for network with latency)\n");
    COMMON_CONFIG_SHOW_INT(rdma_delay_ms,0);
  }

  COMMON_CONFIG_IS_DEFAULT_INT(rdma_delay_threshold,12);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// RDMA write dequeue delay: threshold when reached that prevents RDMA delay to be called\n");
    COMMON_CONFIG_SHOW_INT_OPT(rdma_delay_threshold,12,"0:64");
  }

  COMMON_CONFIG_IS_DEFAULT_BOOL(mandatory_device_label,False);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Whether RozoFS devices must mandatorily be identified by a valid label.\n");
    pChar += rozofs_string_append(pChar,"// Storages will not mount any device not having a valid RozoFS label.\n");
    COMMON_CONFIG_SHOW_BOOL(mandatory_device_label,False);
  }
  return pChar;
}
/*____________________________________________________________________________________________
**
** storcli scope configuration parameters
**
*/
char * save_common_config_module_storcli(char * pChar) {

  pChar += rozofs_string_append(pChar,"#____________________________________________________________\n");
  pChar += rozofs_string_append(pChar,"# ");
  pChar += rozofs_string_append(pChar,"storcli");
  pChar += rozofs_string_append(pChar," scope configuration parameters\n");
  pChar += rozofs_string_append(pChar,"#____________________________________________________________\n\n");

  COMMON_CONFIG_IS_DEFAULT_BOOL(rdma_enable,False);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// When that flag is asserted, the storcli uses RDMA when storio supports it\n");
    COMMON_CONFIG_SHOW_BOOL(rdma_enable,False);
  }

  COMMON_CONFIG_IS_DEFAULT_BOOL(rdma_full,False);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// When that flag is asserted, the storcli uses RDMA for data transfer and RPC messages\n");
    COMMON_CONFIG_SHOW_BOOL(rdma_full,False);
  }

  COMMON_CONFIG_IS_DEFAULT_INT(min_rmda_size_KB,64);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Minimum read/write size in KB to trigger RDMA transfer\n");
    COMMON_CONFIG_SHOW_INT(min_rmda_size_KB,64);
  }

  COMMON_CONFIG_IS_DEFAULT_INT(mojette_thread_count,4);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// number of Mojette threads\n");
    COMMON_CONFIG_SHOW_INT_OPT(mojette_thread_count,4,"1:4");
  }
  return pChar;
}
/*____________________________________________________________________________________________
**
** expbt scope configuration parameters
**
*/
char * save_common_config_module_expbt(char * pChar) {

  pChar += rozofs_string_append(pChar,"#____________________________________________________________\n");
  pChar += rozofs_string_append(pChar,"# ");
  pChar += rozofs_string_append(pChar,"expbt");
  pChar += rozofs_string_append(pChar," scope configuration parameters\n");
  pChar += rozofs_string_append(pChar,"#____________________________________________________________\n\n");

  COMMON_CONFIG_IS_DEFAULT_BOOL(expbt_active,False);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Whether export file tracking reader for rozofsmount batch is enabled\n");
    COMMON_CONFIG_SHOW_BOOL(expbt_active,False);
  }

  COMMON_CONFIG_IS_DEFAULT_INT(nb_expbt_thread,4);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"/// Number of file tracking reader threads.\n");
    COMMON_CONFIG_SHOW_INT_OPT(nb_expbt_thread,4,"2:32");
  }

  COMMON_CONFIG_IS_DEFAULT_INT(expbt_buf_cnt,32);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Number of STORIO receive buffer.\n");
    COMMON_CONFIG_SHOW_INT_OPT(expbt_buf_cnt,32,"8:128");
  }
  return pChar;
}
/*____________________________________________________________________________________________
**
** batch scope configuration parameters
**
*/
char * save_common_config_module_batch(char * pChar) {

  pChar += rozofs_string_append(pChar,"#____________________________________________________________\n");
  pChar += rozofs_string_append(pChar,"# ");
  pChar += rozofs_string_append(pChar,"batch");
  pChar += rozofs_string_append(pChar," scope configuration parameters\n");
  pChar += rozofs_string_append(pChar,"#____________________________________________________________\n\n");

  COMMON_CONFIG_IS_DEFAULT_INT(dirent_cache_size,250000);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Max number of entries in the dirent and root bitmap caches\n");
    COMMON_CONFIG_SHOW_INT_OPT(dirent_cache_size,250000,"2:500000");
  }

  COMMON_CONFIG_IS_DEFAULT_INT(dirent_garbage_delay,5);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// retention delay before memory release for dirent and bitmap entries in cache (seconds)\n");
    COMMON_CONFIG_SHOW_INT_OPT(dirent_garbage_delay,5,"1:60");
  }

  COMMON_CONFIG_IS_DEFAULT_INT(trk_cache_size,2048);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// Max number of entries in tracking file cache\n");
    COMMON_CONFIG_SHOW_INT_OPT(trk_cache_size,2048,"32:8192");
  }

  COMMON_CONFIG_IS_DEFAULT_INT(trk_garbage_delay,5);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// retention delay before memory release in tracking file cache (seconds)\n");
    COMMON_CONFIG_SHOW_INT_OPT(trk_garbage_delay,5,"1:60");
  }

  COMMON_CONFIG_IS_DEFAULT_INT(trk_expiration_delay,120);
  if (isDefaultValue==0) {
    pChar += rozofs_string_append(pChar,"// expiration delay of an entry of the tracking file cache (seconds)\n");
    COMMON_CONFIG_SHOW_INT_OPT(trk_expiration_delay,120,"4:600");
  }
  return pChar;
}
/*____________________________________________________________________________________________
**
** Save configuration parameter on disk
** 
** @param pChar   Parameter name
** @param value   New value to set
** 
** @retval 1 on success, 0 else
*/
static inline int common_config_generated_save(char * pChar) {
  char *pBuff;
  int   fd;
  char  saved_file[256];

  /*
  ** Save previous file
  */
  time_t t = time(NULL);
  struct tm tm = *localtime(&t);
  sprintf(saved_file,"%s_%2.2d-%2.2d-%2.2d_%2.2d:%2.2d:%2.2d", common_config_file_name,tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);
  rename(common_config_file_name,saved_file);

  /*
  ** Creat a new file
  */
  fd = open(common_config_file_name,O_CREAT|O_TRUNC|O_APPEND|O_WRONLY,0777);
  if (fd < 0) {
    pChar += rozofs_string_append_error(pChar,"Can not open ");
    pChar += rozofs_string_append_error(pChar,common_config_file_name);
    return -1;
  }
  pBuff = save_common_config_module_global(myBigBuffer);
  if (write(fd,myBigBuffer,pBuff-myBigBuffer)<0) {
    pChar += rozofs_string_append_error(pChar,"Can not write ");
    pChar += rozofs_string_append_error(pChar,common_config_file_name);
    close(fd);
    return -1;
  }
  pBuff = save_common_config_module_export(myBigBuffer);
  if (write(fd,myBigBuffer,pBuff-myBigBuffer)<0) {
    pChar += rozofs_string_append_error(pChar,"Can not write ");
    pChar += rozofs_string_append_error(pChar,common_config_file_name);
    close(fd);
    return -1;
  }
  pBuff = save_common_config_module_client(myBigBuffer);
  if (write(fd,myBigBuffer,pBuff-myBigBuffer)<0) {
    pChar += rozofs_string_append_error(pChar,"Can not write ");
    pChar += rozofs_string_append_error(pChar,common_config_file_name);
    close(fd);
    return -1;
  }
  pBuff = save_common_config_module_storage(myBigBuffer);
  if (write(fd,myBigBuffer,pBuff-myBigBuffer)<0) {
    pChar += rozofs_string_append_error(pChar,"Can not write ");
    pChar += rozofs_string_append_error(pChar,common_config_file_name);
    close(fd);
    return -1;
  }
  pBuff = save_common_config_module_storcli(myBigBuffer);
  if (write(fd,myBigBuffer,pBuff-myBigBuffer)<0) {
    pChar += rozofs_string_append_error(pChar,"Can not write ");
    pChar += rozofs_string_append_error(pChar,common_config_file_name);
    close(fd);
    return -1;
  }
  pBuff = save_common_config_module_expbt(myBigBuffer);
  if (write(fd,myBigBuffer,pBuff-myBigBuffer)<0) {
    pChar += rozofs_string_append_error(pChar,"Can not write ");
    pChar += rozofs_string_append_error(pChar,common_config_file_name);
    close(fd);
    return -1;
  }
  pBuff = save_common_config_module_batch(myBigBuffer);
  if (write(fd,myBigBuffer,pBuff-myBigBuffer)<0) {
    pChar += rozofs_string_append_error(pChar,"Can not write ");
    pChar += rozofs_string_append_error(pChar,common_config_file_name);
    close(fd);
    return -1;
  }
  pChar += rozofs_string_append(pChar,"Saved in ");
  pChar += rozofs_string_append(pChar,common_config_file_name);
  pChar += rozofs_eol(pChar);
  close(fd);
  return 0;
}
/*____________________________________________________________________________________________
**
** common_config diagnostic function
**
*/
char * common_config_generated_show_all_files(char * pChar) {
  char            cmd[256];

  if (common_config_file_is_read==0) {
    pChar += rozofs_string_append_error(pChar,"Can not read configuration file ");
    return pChar;
  }
  sprintf(cmd,"ls -lisa %s*",common_config_file_name);
  uma_dbg_run_system_cmd(cmd, pChar, uma_dbg_get_buffer_len()); 
  return pChar;
}
/*____________________________________________________________________________________________
**
** common_config diagnostic function
**
*/
void common_config_generated_show(char * argv[], uint32_t tcpRef, void *bufRef) {
char *pChar = uma_dbg_get_buffer();
char *pHead;
int     longformat = 0;
char  * moduleName = NULL;

  if (argv[1] != NULL) {

    if (strcmp(argv[1],"reload")==0) {
      common_config_read(NULL);
      pChar += rozofs_string_append(pChar, "File reloaded\n");
      uma_dbg_send(tcpRef, bufRef, TRUE, uma_dbg_get_buffer());
      return;
    }

    if (strcmp(argv[1],"set")==0) {
      if ((argv[2] == NULL)||(argv[3] == NULL)) {
        pChar += rozofs_string_append_error(pChar, "Missing <parameter> and/or <value>\n");
        uma_dbg_send(tcpRef, bufRef, TRUE, uma_dbg_get_buffer());
        return;
      }
      common_config_generated_set(pChar, argv[2],argv[3]);
      uma_dbg_send(tcpRef, bufRef, TRUE, uma_dbg_get_buffer());
      return;
    }

    if (strcmp(argv[1],"search")==0) {
      if (argv[2] == NULL) {
        pChar += rozofs_string_append_error(pChar, "Missing <parameter>\n");
        uma_dbg_send(tcpRef, bufRef, TRUE, uma_dbg_get_buffer());
        return;
      }
      common_config_generated_search(pChar, argv[2]);
      uma_dbg_send(tcpRef, bufRef, TRUE, uma_dbg_get_buffer());
      return;
    }

    if (strcmp(argv[1],"save")==0) {
      common_config_generated_save(pChar);
      uma_dbg_send(tcpRef, bufRef, TRUE, uma_dbg_get_buffer());
      return;
    }

    if (strcmp(argv[1],"files")==0) {
      common_config_generated_show_all_files(pChar);
      uma_dbg_send(tcpRef, bufRef, TRUE, uma_dbg_get_buffer());
      return;
    }

    if (strcmp(argv[1],"long")==0) {
      longformat = 1;
      moduleName = argv[2];
    }
    else {
      moduleName = argv[1];
      if (argv[2] != NULL) {
        if (strcmp(argv[2],"long")==0) {
          longformat = 1;
        }
      }
    }

    if (moduleName != NULL) {
      if (strcasecmp("global",moduleName)==0) {
        if ((pHead = (char *)ruc_buf_getPayload(bufRef)) == NULL) {
          severe( "ruc_buf_getPayload(%p)", bufRef );
          return;
        }
        /*
        ** Set the command recall string
        */
        pChar = uma_dbg_cmd_recall((UMA_MSGHEADER_S *)pHead);
        if (longformat) {
          pChar = show_common_config_module_global(pChar);
        } else {
          pChar = show_common_config_module_global_short(pChar);
        } 
        uma_dbg_send_buffer(tcpRef, bufRef, pChar-pHead, TRUE);
        return;
      }
      else if (strcasecmp("export",moduleName)==0) {
        if ((pHead = (char *)ruc_buf_getPayload(bufRef)) == NULL) {
          severe( "ruc_buf_getPayload(%p)", bufRef );
          return;
        }
        /*
        ** Set the command recall string
        */
        pChar = uma_dbg_cmd_recall((UMA_MSGHEADER_S *)pHead);
        if (longformat) {
          pChar = show_common_config_module_export(pChar);
        } else {
          pChar = show_common_config_module_export_short(pChar);
        } 
        uma_dbg_send_buffer(tcpRef, bufRef, pChar-pHead, TRUE);
        return;
      }
      else if (strcasecmp("client",moduleName)==0) {
        if ((pHead = (char *)ruc_buf_getPayload(bufRef)) == NULL) {
          severe( "ruc_buf_getPayload(%p)", bufRef );
          return;
        }
        /*
        ** Set the command recall string
        */
        pChar = uma_dbg_cmd_recall((UMA_MSGHEADER_S *)pHead);
        if (longformat) {
          pChar = show_common_config_module_client(pChar);
        } else {
          pChar = show_common_config_module_client_short(pChar);
        } 
        uma_dbg_send_buffer(tcpRef, bufRef, pChar-pHead, TRUE);
        return;
      }
      else if (strcasecmp("storage",moduleName)==0) {
        if ((pHead = (char *)ruc_buf_getPayload(bufRef)) == NULL) {
          severe( "ruc_buf_getPayload(%p)", bufRef );
          return;
        }
        /*
        ** Set the command recall string
        */
        pChar = uma_dbg_cmd_recall((UMA_MSGHEADER_S *)pHead);
        if (longformat) {
          pChar = show_common_config_module_storage(pChar);
        } else {
          pChar = show_common_config_module_storage_short(pChar);
        } 
        uma_dbg_send_buffer(tcpRef, bufRef, pChar-pHead, TRUE);
        return;
      }
      else if (strcasecmp("storcli",moduleName)==0) {
        if ((pHead = (char *)ruc_buf_getPayload(bufRef)) == NULL) {
          severe( "ruc_buf_getPayload(%p)", bufRef );
          return;
        }
        /*
        ** Set the command recall string
        */
        pChar = uma_dbg_cmd_recall((UMA_MSGHEADER_S *)pHead);
        if (longformat) {
          pChar = show_common_config_module_storcli(pChar);
        } else {
          pChar = show_common_config_module_storcli_short(pChar);
        } 
        uma_dbg_send_buffer(tcpRef, bufRef, pChar-pHead, TRUE);
        return;
      }
      else if (strcasecmp("expbt",moduleName)==0) {
        if ((pHead = (char *)ruc_buf_getPayload(bufRef)) == NULL) {
          severe( "ruc_buf_getPayload(%p)", bufRef );
          return;
        }
        /*
        ** Set the command recall string
        */
        pChar = uma_dbg_cmd_recall((UMA_MSGHEADER_S *)pHead);
        if (longformat) {
          pChar = show_common_config_module_expbt(pChar);
        } else {
          pChar = show_common_config_module_expbt_short(pChar);
        } 
        uma_dbg_send_buffer(tcpRef, bufRef, pChar-pHead, TRUE);
        return;
      }
      else if (strcasecmp("batch",moduleName)==0) {
        if ((pHead = (char *)ruc_buf_getPayload(bufRef)) == NULL) {
          severe( "ruc_buf_getPayload(%p)", bufRef );
          return;
        }
        /*
        ** Set the command recall string
        */
        pChar = uma_dbg_cmd_recall((UMA_MSGHEADER_S *)pHead);
        if (longformat) {
          pChar = show_common_config_module_batch(pChar);
        } else {
          pChar = show_common_config_module_batch_short(pChar);
        } 
        uma_dbg_send_buffer(tcpRef, bufRef, pChar-pHead, TRUE);
        return;
      }
      else {
        pChar += rozofs_string_append_error(pChar, "Unexpected configuration scope\n");
        uma_dbg_send(tcpRef, bufRef, TRUE, uma_dbg_get_buffer());
        return;
      }
    }
  }

  if ((pHead = (char *)ruc_buf_getPayload(bufRef)) == NULL) {
    severe( "ruc_buf_getPayload(%p)", bufRef );
    return;
  }
  /*
  ** Set the command recall string
  */
  pChar = uma_dbg_cmd_recall((UMA_MSGHEADER_S *)pHead);
  if (common_config_file_is_read==0) {
    pChar += rozofs_string_append_error(pChar,"Can not read configuration file ");
  }
  
  
  if (longformat) {
    pChar = show_common_config_module_global(pChar);
  } else {
    pChar = show_common_config_module_global_short(pChar);
  } 
  uma_dbg_send_buffer(tcpRef, bufRef, pChar-pHead, FALSE);
  
  bufRef = uma_dbg_get_new_buffer(tcpRef);
  if (bufRef == NULL) {
    warning( "uma_dbg_get_new_buffer() Buffer depletion");
    return;
  }
  if ((pHead = (char *)ruc_buf_getPayload(bufRef)) == NULL) {
    severe( "ruc_buf_getPayload(%p)", bufRef );
    return;
  }
  pChar = pHead+sizeof(UMA_MSGHEADER_S);
  *pChar = 0;
  
  if (longformat) {
    pChar = show_common_config_module_export(pChar);
  } else {
    pChar = show_common_config_module_export_short(pChar);
  } 
  uma_dbg_send_buffer(tcpRef, bufRef, pChar-pHead, FALSE);
  
  bufRef = uma_dbg_get_new_buffer(tcpRef);
  if (bufRef == NULL) {
    warning( "uma_dbg_get_new_buffer() Buffer depletion");
    return;
  }
  if ((pHead = (char *)ruc_buf_getPayload(bufRef)) == NULL) {
    severe( "ruc_buf_getPayload(%p)", bufRef );
    return;
  }
  pChar = pHead+sizeof(UMA_MSGHEADER_S);
  *pChar = 0;
  
  if (longformat) {
    pChar = show_common_config_module_client(pChar);
  } else {
    pChar = show_common_config_module_client_short(pChar);
  } 
  uma_dbg_send_buffer(tcpRef, bufRef, pChar-pHead, FALSE);
  
  bufRef = uma_dbg_get_new_buffer(tcpRef);
  if (bufRef == NULL) {
    warning( "uma_dbg_get_new_buffer() Buffer depletion");
    return;
  }
  if ((pHead = (char *)ruc_buf_getPayload(bufRef)) == NULL) {
    severe( "ruc_buf_getPayload(%p)", bufRef );
    return;
  }
  pChar = pHead+sizeof(UMA_MSGHEADER_S);
  *pChar = 0;
  
  if (longformat) {
    pChar = show_common_config_module_storage(pChar);
  } else {
    pChar = show_common_config_module_storage_short(pChar);
  } 
  uma_dbg_send_buffer(tcpRef, bufRef, pChar-pHead, FALSE);
  
  bufRef = uma_dbg_get_new_buffer(tcpRef);
  if (bufRef == NULL) {
    warning( "uma_dbg_get_new_buffer() Buffer depletion");
    return;
  }
  if ((pHead = (char *)ruc_buf_getPayload(bufRef)) == NULL) {
    severe( "ruc_buf_getPayload(%p)", bufRef );
    return;
  }
  pChar = pHead+sizeof(UMA_MSGHEADER_S);
  *pChar = 0;
  
  if (longformat) {
    pChar = show_common_config_module_storcli(pChar);
  } else {
    pChar = show_common_config_module_storcli_short(pChar);
  } 
  uma_dbg_send_buffer(tcpRef, bufRef, pChar-pHead, FALSE);
  
  bufRef = uma_dbg_get_new_buffer(tcpRef);
  if (bufRef == NULL) {
    warning( "uma_dbg_get_new_buffer() Buffer depletion");
    return;
  }
  if ((pHead = (char *)ruc_buf_getPayload(bufRef)) == NULL) {
    severe( "ruc_buf_getPayload(%p)", bufRef );
    return;
  }
  pChar = pHead+sizeof(UMA_MSGHEADER_S);
  *pChar = 0;
  
  if (longformat) {
    pChar = show_common_config_module_expbt(pChar);
  } else {
    pChar = show_common_config_module_expbt_short(pChar);
  } 
  uma_dbg_send_buffer(tcpRef, bufRef, pChar-pHead, FALSE);
  
  bufRef = uma_dbg_get_new_buffer(tcpRef);
  if (bufRef == NULL) {
    warning( "uma_dbg_get_new_buffer() Buffer depletion");
    return;
  }
  if ((pHead = (char *)ruc_buf_getPayload(bufRef)) == NULL) {
    severe( "ruc_buf_getPayload(%p)", bufRef );
    return;
  }
  pChar = pHead+sizeof(UMA_MSGHEADER_S);
  *pChar = 0;
  
  if (longformat) {
    pChar = show_common_config_module_batch(pChar);
  } else {
    pChar = show_common_config_module_batch_short(pChar);
  } 
  uma_dbg_send_buffer(tcpRef, bufRef, pChar-pHead, FALSE);
  
  bufRef = uma_dbg_get_new_buffer(tcpRef);
  if (bufRef == NULL) {
    warning( "uma_dbg_get_new_buffer() Buffer depletion");
    return;
  }
  if ((pHead = (char *)ruc_buf_getPayload(bufRef)) == NULL) {
    severe( "ruc_buf_getPayload(%p)", bufRef );
    return;
  }
  pChar = pHead+sizeof(UMA_MSGHEADER_S);
  *pChar = 0;
  pChar += rozofs_string_append(pChar,"#____________________________________________________________\n");
  pChar += rozofs_string_append(pChar,"# ");
  pChar += rozofs_string_append(pChar," common_config file is ");
  pChar += rozofs_string_append(pChar,common_config_file_name);
  pChar += rozofs_string_append(pChar,"\n#____________________________________________________________\n\n");
  uma_dbg_send_buffer(tcpRef, bufRef, pChar-pHead, TRUE);
  return;
}
/*____________________________________________________________________________________________
**
** Check the presence of the configuration file
** 
** @param fname   Configuration file of NULL (use default)
**
** @retval  0 if it exist, -1 else
*/
int common_config_does_file_exist(char * fname) {

  if (fname == NULL) {
    strcpy(common_config_file_name,ROZOFS_CONFIG_DIR"/rozofs.conf");
  }
  else {
    strcpy(common_config_file_name,fname); 
  } 

  if (access(common_config_file_name,R_OK)!=0) {
    return -1;
  }
  return 0;
}

/*____________________________________________________________________________________________
**
** Read the configuration file
*/
static inline void common_config_generated_read(char * fname) {
  config_t          cfg; 

  if (common_config_file_is_read == 0) {
    uma_dbg_addTopicAndMan("cconf",show_common_config, man_common_config, 0);
  }

  if (common_config_does_file_exist(fname) != 0) {
    printf("cant access %s: %s.", common_config_file_name, strerror(errno));
    fatal("cant access %s: %s.", common_config_file_name, strerror(errno));
  }

  config_init(&cfg);
  common_config_file_is_read = 1;
  if (config_read_file(&cfg, common_config_file_name) == CONFIG_FALSE) {
    if (errno == ENOENT) {
      info("Missing file %s.", common_config_file_name);
    }
    else {
      severe("cant read %s: %s (line %d).", common_config_file_name, config_error_text(&cfg),config_error_line(&cfg));
    }
    common_config_file_is_read = 0;
  }

  /*
  ** global scope configuration parameters
  */
  // Number of core files that the system is allowed to keep for all the modules of this server. 
  // Older core files are kept while newest are removed.	 
  COMMON_CONFIG_READ_INT_MINMAX(nb_core_file,1,0,8);
  // Directory where the core files are stored. 
  COMMON_CONFIG_READ_STRING(core_file_directory,"");
  // Enables to take into account the NUMA architecture of the board in  
  // order to collocate some RozoFS modules on the same node for memory 
  // access efficiency. 
  COMMON_CONFIG_READ_BOOL(numa_aware,False);
  // Ethernet Adaptor numa node (-1 not significant) 
  COMMON_CONFIG_READ_INT(adaptor_numa_node,-1);
  // processor model: 
  // EPYC: all AMD CPUs  
  // INTEL:   covers E5 & skylake families 
  COMMON_CONFIG_PROCESSOR_MODEL_READ_ENUM(&cfg);
  // Number of slices in the STORIO. 
  COMMON_CONFIG_READ_INT_MINMAX(storio_slice_number,1024,8,(32*1024));
  // File distribution mode upon cluster, storages and devices. Check rozofs.conf manual. 
  // 0         = Cluster size balancing                   + device size balancing 
  // 1,2,3     = Cluster strict round robin               + device write spreading 
  // 4         = Cluster strict round robin               + device read spreading 
  // 5         = Cluster weighted round robin (nb SID)    + device write spreading 
  // 6         = Cluster weighted round robin (nb SID)    + device read spreading 
  // 7         = Cluster weighted round robin (free size) + device write spreading 
  // 6         = Cluster weighted round robin (free size) + device read spreading 
  COMMON_CONFIG_READ_INT_MINMAX(file_distribution_rule,0,0,100);
  // DSCP for exchanges from/to the STORIO. 
  COMMON_CONFIG_READ_INT_MINMAX(storio_dscp,46,0,46);
  // DSCP for exchanges from/to the EXPORTD. 
  COMMON_CONFIG_READ_INT_MINMAX(export_dscp,34,0,34);
  // When that flag is asserted, RozoFS operates in standalone mode only. 
  COMMON_CONFIG_READ_BOOL(standalone,False);
  // rozodiag mode 
  // server     Each RozoFS module listen for rozodiag command on its dedicated server port 
  // client     Each RozoFS module is client of a local rozodiag server that relays rozodiag commands 
  // both       Each RozoFS module is client as well as server 
  //     
  COMMON_CONFIG_DIAGNOSTIC_MODE_READ_ENUM(&cfg);
  /*
  ** export scope configuration parameters
  */
  // Max number of file that the exportd can remove from storages in a run. 
  // A new run occurs every 2 seconds. 
  COMMON_CONFIG_READ_INT(trashed_file_per_run,1000);
  // High trash water mark when FID recycling is activated. 
  // When the trash has already this number of files, files are no more 
  // deleted but recycled. 
  COMMON_CONFIG_READ_INT_MINMAX(trash_high_threshold,1000,0,1000000);
  // Whether FID recycling feature is activated. 
  COMMON_CONFIG_READ_BOOL(fid_recycle,False);
  COMMON_CONFIG_READ_INT_MINMAX(export_buf_cnt,128,32,1024);
  // To activate export writebehind attributes thread. 
  COMMON_CONFIG_READ_BOOL(export_attr_thread,True);
  // Support of deleted directory/file versioning. 
  COMMON_CONFIG_READ_BOOL(export_versioning,False);
  // Number of MB to account a file for during file distribution phase 
  COMMON_CONFIG_READ_INT(alloc_estimated_mb,1);
  // Delay from which a rozofsmoun client is declared disconnected and its  
  // file locks are automatically removed 
  COMMON_CONFIG_READ_INT_MINMAX(client_flock_timeout,30,15,600);
  // Time out between export and storage for remove and stat 
  COMMON_CONFIG_READ_INT_MINMAX(mproto_timeout,10,1,60);
  // Directory to use on the export to build temporary files. 
  // Used for instance to build list of files to rebuild. 
  COMMON_CONFIG_READ_STRING(export_temporary_dir,"/tmp");
  // To activate workaround that make mkdir respond OK instead of EEXIST 
  // when the directory is already created  
  COMMON_CONFIG_READ_BOOL(mkdir_ok_instead_of_eexist,False);
  // To activate workaround that make mknod respond OK instead of EEXIST 
  // when the file is already created   
  COMMON_CONFIG_READ_BOOL(mknod_ok_instead_of_eexist,False);
  // To disable synchronous write of attributes when set to True 
  COMMON_CONFIG_READ_BOOL(disable_sync_attributes,False);
  // Minimum delay between the deletion request and the effective projections deletion 
  COMMON_CONFIG_READ_INT(deletion_delay,30);
  // Minimum number of inodes that must be available on metadata device to allow a mknod/mkdir operation 
  COMMON_CONFIG_READ_INT(min_metadata_inodes,262144);
  // Minimum available size in MB that must be available on metadata device to allow a mknod/mkdir operation 
  COMMON_CONFIG_READ_INT(min_metadata_MB,2048);
  // Number of trash threads that work in parallel 
  COMMON_CONFIG_READ_INT_MINMAX(nb_trash_thread,2,1,8);
  // Number of thin provisioning threads that work in parallel 
  COMMON_CONFIG_READ_INT_MINMAX(nb_thin_thread,2,1,4);
  // Max number of files that the exportd can submit to storages to get the number of blocks (thin provisioning) in a run. 
  // A new run occurs every 2 seconds. 
  COMMON_CONFIG_READ_INT(thin_scan_file_per_run,1000);
  // Thin provisioning Level 1 hash table size in power of 2 (changing this parameter will take effect on the next export restart)  
  COMMON_CONFIG_READ_INT_MINMAX(thin_lv1_hash_tb_size,10,6,128);
  // Guard delay in seconds between two file scanning of a file that belongs to an exportd configured for thin provisioning 
  COMMON_CONFIG_READ_INT_MINMAX(expthin_guard_delay_sec,10,1,600);
  // Guard delay associated with directory re-write used for tracking children changes within a directory  
  COMMON_CONFIG_READ_INT_MINMAX(expdir_guard_delay_sec,10,1,7200);
  // Maximum number of entries that the export level 2 cache can contain (unit is KB)  
  COMMON_CONFIG_READ_INT_MINMAX(level2_cache_max_entries_kb,512,1,4096);
  // Whether file locks must be persistent on exportd restart/switchover or not 
  COMMON_CONFIG_READ_BOOL(persistent_file_locks,False);
  // Minimum % of free space in a volume. 
  // When the free space of a volume reaches this value, file creation requests 
  // receive back ENOSPC in order to try to avoid later write errors. 
  // A value of 0 means there is no limit on the volume. 
  // A value of 100 forbids every file creation. 
  COMMON_CONFIG_READ_INT_MINMAX(minimum_free_size_percent,4,0,100);
  /*
  ** client scope configuration parameters
  */
  // Whether STORCLI acknowleges write request on inverse or forward STORIO responses. 
  COMMON_CONFIG_READ_BOOL(wr_ack_on_inverse,False);
  // To indicate if we can respond before write_pending reaches 0. 
  COMMON_CONFIG_READ_BOOL(wr_pending_anticipated,False);
  // To activate rozofsmount reply fuse threads. 
  COMMON_CONFIG_READ_INT_MINMAX(rozofsmount_fuse_reply_thread,0,0,4);
  // To activate fast reconnect from client to exportd 
  COMMON_CONFIG_READ_BOOL(client_fast_reconnect,False);
  // delay is minutes after which a file is considered as an archived file (unit is minute) 
  COMMON_CONFIG_READ_INT_MINMAX(archive_file_delay,10,0,3600);
  // dentry cache timeout for archive file type (unit is second) 
  COMMON_CONFIG_READ_INT_MINMAX(archive_file_dentry_timeout,30,0,300);
  // attribute cache timeout for archive file type (unit is second) 
  COMMON_CONFIG_READ_INT_MINMAX(archive_file_attr_timeout,30,0,300);
  // When that flag is asserted, the rozofsmount client can cache the extended attributes 
  COMMON_CONFIG_READ_BOOL(client_xattr_cache,False);
  // When that flag is asserted, the rozofsmount client performs setattr in asynchronous mode 
  COMMON_CONFIG_READ_BOOL(async_setattr,False);
  // statfs period in seconds. minimum is 0. 
  COMMON_CONFIG_READ_INT(statfs_period,10);
  // number of Fuse threads 
  COMMON_CONFIG_READ_INT_MINMAX(reply_thread_count,2,1,8);
  // Buffer read by-pass 
  COMMON_CONFIG_READ_BOOL(bufread_bypass,False);
  // When that flag is asserted any storcli can be selected for reading. 
  COMMON_CONFIG_READ_BOOL(storcli_read_parallel,False);
  /*
  ** storage scope configuration parameters
  */
  // Number of sub threads in the storaged 
  COMMON_CONFIG_READ_INT_MINMAX(nb_storaged_subthread,8,2,16);
  /// Number of disk threads in the STORIO. 
  COMMON_CONFIG_READ_INT_MINMAX(nb_disk_thread,4,2,64);
  /// Number of RDMA write threads in the STORIO. 
  COMMON_CONFIG_READ_INT_MINMAX(nb_write_rdma_threads,4,2,64);
  // assert that Boolean to activate the RDMA write threads. 
  COMMON_CONFIG_READ_BOOL(rdma_write_thread_enable,False);
  // Whether CRC32 MUST be checked by STORIO. 
  COMMON_CONFIG_READ_BOOL(crc32c_check,True);
  // Whether CRC32 MUST be computed by STORIO. 
  COMMON_CONFIG_READ_BOOL(crc32c_generate,True);
  // Whether CRC32 MUST be absolutly hardware computed by STORIO. 
  COMMON_CONFIG_READ_BOOL(crc32c_hw_forced,False);
  // Whether STORIO device monitoring should avoid reading from  
  // devices when no access have occured for read or write. This 
  // enables disk spin down to occur. 
  COMMON_CONFIG_READ_BOOL(allow_disk_spin_down,False);
  // Over which device usage threashold should the STORIO log the event.  
  COMMON_CONFIG_READ_INT_MINMAX(disk_usage_threshold,0,0,100);
  // Over which device read delay threashold should the STORIO log the event.  
  COMMON_CONFIG_READ_INT(disk_read_threshold,0);
  // Over which device write delay threashold should the STORIO log the event.  
  COMMON_CONFIG_READ_INT(disk_write_threshold,0);
  // Number of STORIO receive buffer. 
  COMMON_CONFIG_READ_INT_MINMAX(storio_buf_cnt,256,32,1024);
  // Number of block to which the chunk files should be truncated on storage  
  // node at the time it is recycled. 
  COMMON_CONFIG_READ_INT(recycle_truncate_blocks,0);
  // Name of an executable file that the storaged should call at startup 
  COMMON_CONFIG_READ_STRING(storaged_start_script,"");
  // Whether the storage has to automount the devices 
  COMMON_CONFIG_READ_BOOL(device_automount,False);
  // automount path where the devices should be mounted 
  COMMON_CONFIG_READ_STRING(device_automount_path,"/srv/rozofs/storages");
  // Device mounting options 
  COMMON_CONFIG_READ_STRING(device_automount_option,"");
  // Directory to use on the storage node to build temporary files. 
  // Used for instance by the rebuild process. 
  COMMON_CONFIG_READ_STRING(storage_temporary_dir,"/tmp");
  // self healing : Paralellism factor for device self healing feature 
  // i.e the number of process to run rebuild in // 
  COMMON_CONFIG_READ_INT_MINMAX(device_self_healing_process,8,1,64);
  // self healing : Fault duration in minutes before device selfhealing starts 
  COMMON_CONFIG_READ_INT_MINMAX(device_selfhealing_delay,15,0,10000);
  // self healing :  throughput limitation in MB/s per rebuild process in // 
  // for reading external projections. The writing on disk is only 
  // 1/2 of that in layout 0, 1/4 in layout 1... 
  // 0 means no limit 
  COMMON_CONFIG_READ_INT_MINMAX(device_selfhealing_read_throughput,40,0,10000);
  // self healing : possible modes 
  // spareOnly  only self repair on a spare disk 
  // relocate   also repair on remaining disks when no spare available 
  // resecure   repair on spare device when available, and then resecure files on 
  //            spare storages when no spare device is available 
  // none       No self healing is processed. Only manual rebuild is allowed. 
  COMMON_CONFIG_DEVICE_SELFHEALING_MODE_READ_ENUM(&cfg);
  // Export host names or IP addresses separated with /  
  // Required for selfhealing. 
  // Required for spare file restoring to its nominal location. 
  COMMON_CONFIG_READ_STRING(export_hosts,"");
  // Spare file restoring : whether the service is active or not 
  COMMON_CONFIG_READ_BOOL(spare_restore_enable,True);
  // Spare file restoring : how often the process runs   
  COMMON_CONFIG_READ_INT(spare_restore_loop_delay,240);
  // Default rebuild reloop value  
  // Mainly used to help simulation 
  COMMON_CONFIG_READ_INT(default_rebuild_reloop,4);
  // Spare file restoring : throughput limitation for reading and analyzing spare files in MB/s 
  // 0 means no limit 
  COMMON_CONFIG_READ_INT(spare_restore_read_throughput,10);
  // Storio number of FID context in 1K unit 
  COMMON_CONFIG_READ_INT(storio_fidctx_ctx,256);
  // Spare file restoring : Number of spare file context in 1K unit 
  COMMON_CONFIG_READ_INT(spare_restore_spare_ctx,16);
  // RDMA write dequeue delay: delay in ms before dequeueing a new request (for network with latency) 
  COMMON_CONFIG_READ_INT(rdma_delay_ms,0);
  // RDMA write dequeue delay: threshold when reached that prevents RDMA delay to be called 
  COMMON_CONFIG_READ_INT_MINMAX(rdma_delay_threshold,12,0,64);
  // Whether RozoFS devices must mandatorily be identified by a valid label. 
  // Storages will not mount any device not having a valid RozoFS label. 
  COMMON_CONFIG_READ_BOOL(mandatory_device_label,False);
  /*
  ** storcli scope configuration parameters
  */
  // When that flag is asserted, the storcli uses RDMA when storio supports it 
  COMMON_CONFIG_READ_BOOL(rdma_enable,False);
  // When that flag is asserted, the storcli uses RDMA for data transfer and RPC messages 
  COMMON_CONFIG_READ_BOOL(rdma_full,False);
  // Minimum read/write size in KB to trigger RDMA transfer 
  COMMON_CONFIG_READ_INT(min_rmda_size_KB,64);
  // number of Mojette threads 
  COMMON_CONFIG_READ_INT_MINMAX(mojette_thread_count,4,1,4);
  /*
  ** expbt scope configuration parameters
  */
  // Whether export file tracking reader for rozofsmount batch is enabled 
  COMMON_CONFIG_READ_BOOL(expbt_active,False);
  /// Number of file tracking reader threads. 
  COMMON_CONFIG_READ_INT_MINMAX(nb_expbt_thread,4,2,32);
  // Number of STORIO receive buffer. 
  COMMON_CONFIG_READ_INT_MINMAX(expbt_buf_cnt,32,8,128);
  /*
  ** batch scope configuration parameters
  */
  // Max number of entries in the dirent and root bitmap caches 
  COMMON_CONFIG_READ_INT_MINMAX(dirent_cache_size,250000,2,500000);
  // retention delay before memory release for dirent and bitmap entries in cache (seconds) 
  COMMON_CONFIG_READ_INT_MINMAX(dirent_garbage_delay,5,1,60);
  // Max number of entries in tracking file cache 
  COMMON_CONFIG_READ_INT_MINMAX(trk_cache_size,2048,32,8192);
  // retention delay before memory release in tracking file cache (seconds) 
  COMMON_CONFIG_READ_INT_MINMAX(trk_garbage_delay,5,1,60);
  // expiration delay of an entry of the tracking file cache (seconds) 
  COMMON_CONFIG_READ_INT_MINMAX(trk_expiration_delay,120,4,600);
 
  config_destroy(&cfg);
}
#endif
